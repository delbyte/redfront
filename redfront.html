<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Redfront OSINT Workbench ‚Äî All-in-One Intelligence Analysis</title>
<style>
:root{
  --bg:#080808; --panel:#0f0f0f; --muted:#bfbfbf; --red:#c21a1a; --accent:#bf7b2d;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--muted);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
.container{display:grid;grid-template-rows:auto 1fr;gap:10px;padding:12px;min-height:100vh}
.header{display:flex;gap:12px;align-items:center}
.logo{width:64px;height:40px;flex:0 0 auto}
.h1{font-weight:800;color:var(--red);letter-spacing:.06em}
.top-controls{margin-left:auto;display:flex;gap:8px;align-items:center}
.button{background:var(--red);border:0;padding:8px 10px;border-radius:6px;color:#fff;font-weight:700;cursor:pointer}
.layout{display:grid;grid-template-columns:360px 1fr;gap:12px;align-items:start}
.panel{background:linear-gradient(180deg,#0b0b0b,#060606);border-radius:8px;padding:12px;box-shadow:0 6px 20px rgba(0,0,0,.6)}
.small{font-size:13px;color:#b7b7b7}
.filedrop{border:1px dashed rgba(200,30,30,.18);padding:12px;border-radius:6px;text-align:center;color:var(--muted);cursor:pointer}
.console{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;font-size:13px;line-height:1.4;color:#e9e9e9;background:#090909;padding:8px;border-radius:6px;max-height:360px;overflow:auto}
.row{display:flex;gap:8px;align-items:center}
.field{display:flex;flex-direction:column;gap:6px}
.kv{display:flex;justify-content:space-between;border-bottom:1px dashed rgba(255,255,255,.03);padding:6px 0}
.mapwrap{height:240px;background:linear-gradient(180deg,#0a0505,#070707);border-radius:6px;display:flex;align-items:center;justify-content:center;position:relative}
.map{width:100%;height:100%}
.badge{background:#0b0b0b;padding:6px 8px;border-radius:6px;font-size:12px;color:var(--muted)}
.controls{display:flex;gap:8px;flex-wrap:wrap}
.smallmuted{font-size:12px;color:#9a9a9a}
.footer{display:flex;justify-content:space-between;align-items:center;margin-top:6px;color:#888;font-size:12px}
.copy{background:transparent;border:1px solid rgba(255,255,255,.06);padding:6px 8px;border-radius:6px;color:var(--muted);cursor:pointer}
.hint{font-size:12px;color:#777}
@media(max-width:880px){.layout{grid-template-columns:1fr;}}
/* subtle gritty overlay */
.grit{position:absolute;inset:0;pointer-events:none;opacity:.06;mix-blend-mode:overlay}

/* Page System */
.page{min-height:calc(100vh - 100px)}

/* Landing Page Styles */
.command-grid{display:grid;grid-template-rows:auto 1fr;gap:20px;max-width:1200px;margin:0 auto}
.mission-brief{max-width:600px}
.modules-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:16px}

.module-btn{
  background:linear-gradient(135deg,#0d0d0d,#050505);
  border:1px solid rgba(194,26,26,.15);
  padding:20px;
  border-radius:12px;
  color:var(--muted);
  cursor:pointer;
  transition:all 0.3s ease;
  text-align:left;
  display:flex;
  flex-direction:column;
  gap:8px;
  position:relative;
  overflow:hidden;
}

.module-btn:hover{
  border-color:rgba(194,26,26,.4);
  background:linear-gradient(135deg,#111,#080808);
  transform:translateY(-2px);
  box-shadow:0 8px 25px rgba(194,26,26,.15);
}

.module-btn:active{
  transform:translateY(0);
}

.module-btn::before{
  content:'';
  position:absolute;
  top:0;
  left:-100%;
  width:100%;
  height:100%;
  background:linear-gradient(90deg,transparent,rgba(194,26,26,.1),transparent);
  transition:left 0.5s;
}

.module-btn:hover::before{
  left:100%;
}

.module-icon{
  font-size:32px;
  margin-bottom:4px;
  filter:grayscale(1);
  transition:filter 0.3s ease;
}

.module-btn:hover .module-icon{
  filter:grayscale(0);
}

.module-title{
  font-size:16px;
  font-weight:700;
  color:var(--red);
  letter-spacing:0.05em;
}

.module-desc{
  font-size:13px;
  color:#999;
  line-height:1.4;
}

/* Module Header */
.module-header{
  display:flex;
  gap:16px;
  align-items:center;
  margin-bottom:20px;
  padding-bottom:12px;
  border-bottom:1px solid rgba(255,255,255,.05);
}

.nav-btn{
  background:rgba(194,26,26,.1);
  border:1px solid rgba(194,26,26,.3);
  padding:8px 12px;
  border-radius:6px;
  color:var(--red);
  cursor:pointer;
  font-weight:600;
  transition:all 0.2s ease;
  font-size:13px;
}

.nav-btn:hover{
  background:rgba(194,26,26,.2);
  border-color:rgba(194,26,26,.5);
}

.module-title-header{
  font-size:18px;
  font-weight:800;
  color:var(--red);
  letter-spacing:0.1em;
}

/* Enhanced console for better readability */
.console{
  font-family:ui-monospace, 'SF Mono', Consolas, monospace;
  font-size:12px;
  line-height:1.5;
  color:#e9e9e9;
  background:linear-gradient(180deg,#050505,#0a0a0a);
  padding:12px;
  border-radius:6px;
  border:1px solid rgba(255,255,255,.03);
  max-height:400px;
  overflow:auto;
  white-space:pre-wrap;
}

/* Responsive adjustments */
@media(max-width:1024px){
  .modules-grid{grid-template-columns:repeat(auto-fit,minmax(280px,1fr))}
}

@media(max-width:768px){
  .command-grid{gap:16px}
  .modules-grid{grid-template-columns:1fr;gap:12px}
  .module-btn{padding:16px}
  .module-header{flex-direction:column;align-items:flex-start;gap:8px}
}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <svg class="logo" viewBox="0 0 72 48" xmlns="http://www.w3.org/2000/svg" aria-hidden>
      <rect width="72" height="48" fill="#050505"/>
      <g transform="translate(6,6)" stroke="#c21a1a" stroke-width="6" stroke-linecap="square" fill="none">
        <path d="M0 0h24v36"/>
        <path d="M30 0v36H6"/>
      </g>
    </svg>
    <div>
      <div class="h1">Redfront OSINT Workbench</div>
      <div class="small">All-in-one tactical OSINT ‚Äî multi-format analysis & intelligence extraction</div>
    </div>
    <div class="top-controls">
      <div class="badge smallmuted" id="status">idle</div>
      <button class="button" id="exportBtn" title="Download JSON report">EXPORT</button>
    </div>
  </div>

  <!-- Landing Page -->
  <div id="landingPage" class="page">
    <div class="command-grid">
      <div class="mission-brief panel">
        <div class="small">MISSION BRIEFING</div>
        <div style="margin-top:12px;line-height:1.6;color:#ddd">
          <div style="font-size:16px;font-weight:700;color:var(--red);margin-bottom:8px">REDFRONT OSINT WORKBENCH</div>
          <div>Multi-domain intelligence analysis platform for tactical operations. Select your analysis module to begin intelligence gathering and threat assessment.</div>
          <div style="margin-top:12px;padding:8px;background:rgba(194,26,26,.08);border-radius:6px;border-left:3px solid var(--red)">
            <div style="font-size:12px;font-weight:700;color:var(--red)">CLASSIFIED</div>
            <div style="font-size:12px;margin-top:4px">All operations conducted locally. Zero network exposure.</div>
          </div>
        </div>
      </div>

      <div class="modules-grid">
        <button class="module-btn" data-module="file">
          <div class="module-icon">üìÅ</div>
          <div class="module-title">FILE ANALYSIS</div>
          <div class="module-desc">Binary analysis, hash extraction, threat assessment</div>
        </button>

        <button class="module-btn" data-module="url">
          <div class="module-icon">üåê</div>
          <div class="module-title">URL INTELLIGENCE</div>
          <div class="module-desc">Domain analysis, subdomain enumeration, IOC extraction</div>
        </button>

        <button class="module-btn" data-module="text">
          <div class="module-icon">üìÑ</div>
          <div class="module-title">TEXT ANALYSIS</div>
          <div class="module-desc">Intelligence extraction from documents and logs</div>
        </button>

        <button class="module-btn" data-module="social">
          <div class="module-icon">üì±</div>
          <div class="module-title">SOCIAL INTEL</div>
          <div class="module-desc">Social media analysis and sentiment assessment</div>
        </button>

        <button class="module-btn" data-module="network">
          <div class="module-icon">üîó</div>
          <div class="module-title">NETWORK MAPPING</div>
          <div class="module-desc">Entity relationship visualization and graph analysis</div>
        </button>

        <button class="module-btn" data-module="reports">
          <div class="module-icon">üìä</div>
          <div class="module-title">INTEL REPORTS</div>
          <div class="module-desc">Export findings and generate intelligence summaries</div>
        </button>

        <button class="module-btn" data-module="email">
          <div class="module-icon">üìß</div>
          <div class="module-title">EMAIL OSINT</div>
          <div class="module-desc">Email validation, breach checks, domain analysis</div>
        </button>

        <button class="module-btn" data-module="phone">
          <div class="module-icon">üìû</div>
          <div class="module-title">PHONE INTEL</div>
          <div class="module-desc">Number validation, carrier lookup, location data</div>
        </button>

        <button class="module-btn" data-module="crypto">
          <div class="module-icon">‚Çø</div>
          <div class="module-title">CRYPTO TRACKER</div>
          <div class="module-desc">Blockchain analysis, wallet tracking, transaction intel</div>
        </button>

        <button class="module-btn" data-module="ip">
          <div class="module-icon">üåç</div>
          <div class="module-title">IP GEOLOCATION</div>
          <div class="module-desc">IP analysis, geolocation, ISP detection, threat intel</div>
        </button>

        <button class="module-btn" data-module="username">
          <div class="module-icon">üë§</div>
          <div class="module-title">USERNAME HUNTER</div>
          <div class="module-desc">Cross-platform username enumeration and analysis</div>
        </button>

        <button class="module-btn" data-module="metadata">
          <div class="module-icon">üîç</div>
          <div class="module-title">METADATA EXTRACTOR</div>
          <div class="module-desc">EXIF data, document properties, hidden information</div>
        </button>
      </div>
    </div>
  </div>

  <!-- File Analysis Module -->
  <div id="fileModule" class="page" style="display:none">
    <div class="module-header">
      <button class="nav-btn" onclick="showPage('landing')">‚Üê COMMAND CENTER</button>
      <div>
        <div class="module-title-header">FILE ANALYSIS MODULE</div>
        <div class="small">Binary analysis, malware detection, hash extraction</div>
      </div>
    </div>
    <div class="layout">
      <div class="panel">
        <div class="small">FILE INPUT</div>
        <div id="filedrop" class="filedrop" tabindex="0">
          Drag & drop files or click to select<br>
          <span style="font-size:11px;color:#888">Supports: executables, documents, images, archives</span>
        </div>
        <div style="margin-top:12px">
          <div class="small">FILE HASH</div>
          <div class="kv">
            <div style="color:#aaa;font-size:13px">SHA-256</div>
            <div id="hash" class="smallmuted">‚Äî</div>
          </div>
          <div style="height:8px"></div>
          <button id="copyHash" class="copy" title="Copy hash">COPY HASH</button>
        </div>
      </div>
      <div class="panel">
        <div class="small">ANALYSIS RESULTS</div>
        <div id="meta" class="console" aria-live="polite">No file selected. Upload a file to begin analysis.</div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <button id="copyIntel" class="copy">COPY REPORT</button>
          <div style="flex:1"></div>
          <div class="smallmuted" id="threatLevel">threat: ‚Äî</div>
        </div>
      </div>
    </div>
  </div>

  <!-- URL Analysis Module -->
  <div id="urlModule" class="page" style="display:none">
    <div class="module-header">
      <button class="nav-btn" onclick="showPage('landing')">‚Üê COMMAND CENTER</button>
      <div>
        <div class="module-title-header">URL INTELLIGENCE MODULE</div>
        <div class="small">Web scraping, domain analysis, tech stack detection</div>
      </div>
    </div>
    <div class="layout">
      <div class="panel">
        <div class="small">URL INPUT</div>
        <input id="urlin" placeholder="https://example.com" style="width:100%;margin-top:6px;padding:8px;border-radius:6px;background:#0b0b0b;border:1px solid rgba(255,255,255,.04);color:#eee"/>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="analyzeUrl" class="button">ANALYZE URL</button>
          <button id="scrapeUrl" class="button">SCRAPE CONTENT</button>
        </div>
        <div style="margin-top:8px">
          <label style="display:flex;align-items:center;gap:6px;font-size:12px;color:#999">
            <input type="checkbox" id="deepScan" style="accent-color:var(--red)">
            Deep scan (slower, more thorough)
          </label>
        </div>
        <div class="hint" style="margin-top:8px">Extracts tech stack, headers, links, social media, contact info</div>
      </div>
      <div class="panel">
        <div class="small">ANALYSIS RESULTS</div>
        <div id="urlMeta" class="console" aria-live="polite">Enter a URL to begin analysis.</div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <button id="copyUrlIntel" class="copy">COPY REPORT</button>
          <button id="copyUrls" class="copy">COPY URLS</button>
          <div style="flex:1"></div>
          <div class="smallmuted" id="urlThreatLevel">threat: ‚Äî</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Text Analysis Module -->
  <div id="textModule" class="page" style="display:none">
    <div class="module-header">
      <button class="nav-btn" onclick="showPage('landing')">‚Üê COMMAND CENTER</button>
      <div>
        <div class="module-title-header">TEXT ANALYSIS MODULE</div>
        <div class="small">Intelligence extraction from documents and logs</div>
      </div>
    </div>
    <div class="layout">
      <div class="panel">
        <div class="small">TEXT INPUT</div>
        <textarea id="textin" placeholder="Paste tweets, posts, messages, source code, logs, or any text content..." style="width:100%;height:200px;margin-top:6px;padding:8px;border-radius:6px;background:#0b0b0b;border:1px solid rgba(255,255,255,.04);color:#eee"></textarea>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="analyzeText" class="button">EXTRACT INTEL</button>
        </div>
        <div class="hint" style="margin-top:8px">Extracts emails, domains, IPs, phone numbers, handles, crypto addresses</div>
      </div>
      <div class="panel">
        <div class="small">ANALYSIS RESULTS</div>
        <div id="textMeta" class="console" aria-live="polite">Enter text to begin intelligence extraction.</div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <button id="copyTextIntel" class="copy">COPY REPORT</button>
          <button id="copyIOCs" class="copy">COPY IOCS</button>
          <div style="flex:1"></div>
          <div class="smallmuted" id="textThreatLevel">threat: ‚Äî</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Social Media Module -->
  <div id="socialModule" class="page" style="display:none">
    <div class="module-header">
      <button class="nav-btn" onclick="showPage('landing')">‚Üê COMMAND CENTER</button>
      <div>
        <div class="module-title-header">SOCIAL INTELLIGENCE MODULE</div>
        <div class="small">Social media analysis and sentiment assessment</div>
      </div>
    </div>
    <div class="layout">
      <div class="panel">
        <div class="small">SOCIAL MEDIA INPUT</div>
        <textarea id="socialTextin" placeholder="Paste social media posts, profiles, conversations..." style="width:100%;height:200px;margin-top:6px;padding:8px;border-radius:6px;background:#0b0b0b;border:1px solid rgba(255,255,255,.04);color:#eee"></textarea>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="analyzeSocial" class="button">ANALYZE SOCIAL</button>
        </div>
        <div class="hint" style="margin-top:8px">Sentiment analysis, platform detection, handle extraction</div>
      </div>
      <div class="panel">
        <div class="small">ANALYSIS RESULTS</div>
        <div id="socialMeta" class="console" aria-live="polite">Enter social media content to begin analysis.</div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <button id="copySocialIntel" class="copy">COPY REPORT</button>
          <div style="flex:1"></div>
          <div class="smallmuted" id="socialThreatLevel">sentiment: ‚Äî</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Network Mapping Module -->
  <div id="networkModule" class="page" style="display:none">
    <div class="module-header">
      <button class="nav-btn" onclick="showPage('landing')">‚Üê COMMAND CENTER</button>
      <div>
        <div class="module-title-header">NETWORK MAPPING MODULE</div>
        <div class="small">Entity relationship visualization and graph analysis</div>
      </div>
    </div>
    <div class="layout">
      <div class="panel" style="grid-column:1/-1">
        <div class="small">NETWORK VISUALIZATION</div>
        <div class="mapwrap" id="mapwrap" style="height:400px">
          <svg id="map" class="map" viewBox="0 0 360 180" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <filter id="n">
                <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="1" stitchTiles="stitch"/>
                <feColorMatrix type="saturate" values="0"/>
                <feComponentTransfer><feFuncA type="table" tableValues="0 0.6"/></feComponentTransfer>
              </filter>
            </defs>
            <rect width="360" height="180" fill="#0b0b0b"/>
            <g id="networkLayer"></g>
            <text x="50%" y="50%" fill="#6b6b6b" font-size="12" text-anchor="middle" dy=".35em">Run analysis in other modules to populate network graph</text>
          </svg>
          <svg class="grit" viewBox="0 0 360 180" xmlns="http://www.w3.org/2000/svg"><rect width="360" height="180" filter="url(#n)" fill="#000"/></svg>
        </div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <button id="copyNetworkData" class="copy">EXPORT GRAPH DATA</button>
          <div style="flex:1"></div>
          <div class="smallmuted" id="networkStats">entities: 0</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Reports Module -->
  <div id="reportsModule" class="page" style="display:none">
    <div class="module-header">
      <button class="nav-btn" onclick="showPage('landing')">‚Üê COMMAND CENTER</button>
      <div>
        <div class="module-title-header">INTELLIGENCE REPORTS MODULE</div>
        <div class="small">Export findings and generate intelligence summaries</div>
      </div>
    </div>
    <div class="layout">
      <div class="panel">
        <div class="small">REPORT GENERATION</div>
        <div id="reportSummary" class="console" style="height:300px">No analysis data available. Run analysis in other modules to generate reports.</div>
        <div style="margin-top:8px;display:flex;gap:8px">
          <button id="exportBtn" class="button">EXPORT JSON</button>
          <button id="exportCSV" class="copy">EXPORT CSV</button>
          <button id="exportTXT" class="copy">EXPORT TXT</button>
        </div>
      </div>
      <div class="panel">
        <div class="small">OPERATION SUMMARY</div>
        <div id="operationStats" class="console">
          <div class="kv"><span>Files Analyzed</span><span id="statsFiles">0</span></div>
          <div class="kv"><span>URLs Processed</span><span id="statsUrls">0</span></div>
          <div class="kv"><span>Text Samples</span><span id="statsText">0</span></div>
          <div class="kv"><span>Social Posts</span><span id="statsSocial">0</span></div>
          <div class="kv"><span>Total IOCs</span><span id="statsIOCs">0</span></div>
          <div class="kv"><span>Threat Level</span><span id="statsThreats">LOW</span></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Email OSINT Module -->
  <div id="emailModule" class="page" style="display:none">
    <div class="module-header">
      <button class="nav-btn" onclick="showPage('landing')">‚Üê COMMAND CENTER</button>
      <div>
        <div class="module-title-header">EMAIL OSINT MODULE</div>
        <div class="small">Email validation, domain analysis, breach intelligence</div>
      </div>
    </div>
    <div class="layout">
      <div class="panel">
        <div class="small">EMAIL INPUT</div>
        <input id="emailin" placeholder="target@example.com" style="width:100%;margin-top:6px;padding:8px;border-radius:6px;background:#0b0b0b;border:1px solid rgba(255,255,255,.04);color:#eee"/>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="analyzeEmail" class="button">ANALYZE EMAIL</button>
          <button id="checkBreaches" class="button">CHECK BREACHES</button>
        </div>
        <div class="hint" style="margin-top:8px">Validates email, checks domain reputation, breach databases</div>
      </div>
      <div class="panel">
        <div class="small">EMAIL INTELLIGENCE</div>
        <div id="emailMeta" class="console" aria-live="polite">Enter an email address to begin analysis.</div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <button id="copyEmailIntel" class="copy">COPY REPORT</button>
          <div style="flex:1"></div>
          <div class="smallmuted" id="emailThreatLevel">status: ‚Äî</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Phone Intelligence Module -->
  <div id="phoneModule" class="page" style="display:none">
    <div class="module-header">
      <button class="nav-btn" onclick="showPage('landing')">‚Üê COMMAND CENTER</button>
      <div>
        <div class="module-title-header">PHONE INTELLIGENCE MODULE</div>
        <div class="small">Number validation, carrier lookup, geographic analysis</div>
      </div>
    </div>
    <div class="layout">
      <div class="panel">
        <div class="small">PHONE NUMBER INPUT</div>
        <input id="phonein" placeholder="+1234567890 or 1234567890" style="width:100%;margin-top:6px;padding:8px;border-radius:6px;background:#0b0b0b;border:1px solid rgba(255,255,255,.04);color:#eee"/>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="analyzePhone" class="button">ANALYZE NUMBER</button>
          <button id="validatePhone" class="button">VALIDATE</button>
        </div>
        <div class="hint" style="margin-top:8px">Extracts country, carrier, line type, geographic region</div>
      </div>
      <div class="panel">
        <div class="small">PHONE INTELLIGENCE</div>
        <div id="phoneMeta" class="console" aria-live="polite">Enter a phone number to begin analysis.</div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <button id="copyPhoneIntel" class="copy">COPY REPORT</button>
          <div style="flex:1"></div>
          <div class="smallmuted" id="phoneThreatLevel">validity: ‚Äî</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Crypto Tracker Module -->
  <div id="cryptoModule" class="page" style="display:none">
    <div class="module-header">
      <button class="nav-btn" onclick="showPage('landing')">‚Üê COMMAND CENTER</button>
      <div>
        <div class="module-title-header">CRYPTO TRACKER MODULE</div>
        <div class="small">Blockchain analysis, wallet tracking, transaction intelligence</div>
      </div>
    </div>
    <div class="layout">
      <div class="panel">
        <div class="small">CRYPTO ADDRESS INPUT</div>
        <input id="cryptoin" placeholder="Bitcoin/Ethereum address or transaction hash" style="width:100%;margin-top:6px;padding:8px;border-radius:6px;background:#0b0b0b;border:1px solid rgba(255,255,255,.04);color:#eee"/>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="analyzeCrypto" class="button">ANALYZE ADDRESS</button>
          <button id="trackWallet" class="button">TRACK WALLET</button>
        </div>
        <div class="hint" style="margin-top:8px">Identifies currency, balance, transaction history, risk assessment</div>
      </div>
      <div class="panel">
        <div class="small">BLOCKCHAIN INTELLIGENCE</div>
        <div id="cryptoMeta" class="console" aria-live="polite">Enter a crypto address or transaction hash to begin analysis.</div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <button id="copyCryptoIntel" class="copy">COPY REPORT</button>
          <div style="flex:1"></div>
          <div class="smallmuted" id="cryptoThreatLevel">risk: ‚Äî</div>
        </div>
      </div>
    </div>
  </div>

  <!-- IP Geolocation Module -->
  <div id="ipModule" class="page" style="display:none">
    <div class="module-header">
      <button class="nav-btn" onclick="showPage('landing')">‚Üê COMMAND CENTER</button>
      <div>
        <div class="module-title-header">IP GEOLOCATION MODULE</div>
        <div class="small">IP analysis, geolocation, ISP detection, threat intelligence</div>
      </div>
    </div>
    <div class="layout">
      <div class="panel">
        <div class="small">IP ADDRESS INPUT</div>
        <input id="ipin" placeholder="192.168.1.1 or 2001:db8::1" style="width:100%;margin-top:6px;padding:8px;border-radius:6px;background:#0b0b0b;border:1px solid rgba(255,255,255,.04);color:#eee"/>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="analyzeIP" class="button">ANALYZE IP</button>
          <button id="geolocateIP" class="button">GEOLOCATE</button>
        </div>
        <div class="hint" style="margin-top:8px">Location, ISP, threat level, abuse reports, VPN detection</div>
      </div>
      <div class="panel">
        <div class="small">IP INTELLIGENCE</div>
        <div id="ipMeta" class="console" aria-live="polite">Enter an IP address to begin geolocation analysis.</div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <button id="copyIPIntel" class="copy">COPY REPORT</button>
          <div style="flex:1"></div>
          <div class="smallmuted" id="ipThreatLevel">threat: ‚Äî</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Username Hunter Module -->
  <div id="usernameModule" class="page" style="display:none">
    <div class="module-header">
      <button class="nav-btn" onclick="showPage('landing')">‚Üê COMMAND CENTER</button>
      <div>
        <div class="module-title-header">USERNAME HUNTER MODULE</div>
        <div class="small">Cross-platform username enumeration and analysis</div>
      </div>
    </div>
    <div class="layout">
      <div class="panel">
        <div class="small">USERNAME INPUT</div>
        <input id="usernamein" placeholder="target_username" style="width:100%;margin-top:6px;padding:8px;border-radius:6px;background:#0b0b0b;border:1px solid rgba(255,255,255,.04);color:#eee"/>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="analyzeUsername" class="button">HUNT USERNAME</button>
          <button id="checkSocial" class="button">CHECK SOCIAL</button>
        </div>
        <div class="hint" style="margin-top:8px">Searches across major platforms, social media, forums</div>
      </div>
      <div class="panel">
        <div class="small">USERNAME INTELLIGENCE</div>
        <div id="usernameMeta" class="console" aria-live="polite">Enter a username to begin cross-platform search.</div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <button id="copyUsernameIntel" class="copy">COPY REPORT</button>
          <div style="flex:1"></div>
          <div class="smallmuted" id="usernameThreatLevel">found: 0 platforms</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Metadata Extractor Module -->
  <div id="metadataModule" class="page" style="display:none">
    <div class="module-header">
      <button class="nav-btn" onclick="showPage('landing')">‚Üê COMMAND CENTER</button>
      <div>
        <div class="module-title-header">METADATA EXTRACTOR MODULE</div>
        <div class="small">EXIF data, document properties, hidden information extraction</div>
      </div>
    </div>
    <div class="layout">
      <div class="panel">
        <div class="small">FILE INPUT</div>
        <div id="metadatadrop" class="filedrop" tabindex="0">
          Drop files for metadata extraction<br>
          <span style="font-size:11px;color:#888">Supports: images, documents, videos, audio files</span>
        </div>
        <div style="margin-top:8px">
          <label style="display:flex;align-items:center;gap:6px;font-size:12px;color:#999">
            <input type="checkbox" id="extractGPS" style="accent-color:var(--red)" checked>
            Extract GPS coordinates (if available)
          </label>
        </div>
        <div class="hint" style="margin-top:8px">Extracts creation dates, device info, location data, software details</div>
      </div>
      <div class="panel">
        <div class="small">METADATA ANALYSIS</div>
        <div id="metadataMeta" class="console" aria-live="polite">Upload a file to extract metadata and hidden information.</div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <button id="copyMetadataIntel" class="copy">COPY METADATA</button>
          <div style="flex:1"></div>
          <div class="smallmuted" id="metadataThreatLevel">privacy: ‚Äî</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* ========= REDFRONT OSINT WORKBENCH ========= */
/* Advanced client-side intelligence analysis toolkit */

const el = sel => document.querySelector(sel);
const status = el('#status');
function setStatus(s){ status.textContent = s; }

// Page Navigation System
let currentPage = 'landing';
let globalReport = {
  timestamp: Date.now(),
  sources: [],
  intelligence: {},
  threats: {},
  queries: [],
  files: {},
  stats: {
    filesAnalyzed: 0,
    urlsProcessed: 0,
    textSamples: 0,
    socialPosts: 0,
    totalIOCs: 0,
    maxThreatLevel: 'LOW'
  }
};

function showPage(pageId) {
  // Hide all pages
  document.querySelectorAll('.page').forEach(page => {
    page.style.display = 'none';
  });
  
  // Show target page
  const targetPage = el(`#${pageId}Page`) || el(`#${pageId}Module`);
  if(targetPage) {
    targetPage.style.display = 'block';
    currentPage = pageId;
    
    // Update status
    const pageNames = {
      'landing': 'command center',
      'file': 'file analysis',
      'url': 'url intelligence', 
      'text': 'text analysis',
      'social': 'social intel',
      'network': 'network mapping',
      'reports': 'intel reports'
    };
    setStatus(pageNames[pageId] || pageId);
    
    // Update reports page if navigating there
    if(pageId === 'reports') {
      updateReportsPage();
    }
  }
}

// Initialize page system
document.addEventListener('DOMContentLoaded', () => {
  // Add click handlers for module buttons
  document.querySelectorAll('.module-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const module = btn.dataset.module;
      showPage(module);
    });
  });
  
  // Show landing page initially
  showPage('landing');
});

function updateGlobalStats() {
  const stats = globalReport.stats;
  const intel = globalReport.intelligence;
  
  // Count total IOCs
  let totalIOCs = 0;
  Object.values(intel).forEach(data => {
    if(data.ips) totalIOCs += data.ips.length;
    if(data.domains) totalIOCs += data.domains.length;
    if(data.emails) totalIOCs += data.emails.length;
    if(data.hashes) totalIOCs += data.hashes.length;
    if(data.urls) totalIOCs += data.urls.length;
    if(data.cryptoAddresses) totalIOCs += data.cryptoAddresses.length;
  });
  
  stats.totalIOCs = totalIOCs;
  
  // Update stats in reports page
  if(el('#statsFiles')) {
    el('#statsFiles').textContent = stats.filesAnalyzed;
    el('#statsUrls').textContent = stats.urlsProcessed;
    el('#statsText').textContent = stats.textSamples;
    el('#statsSocial').textContent = stats.socialPosts;
    el('#statsIOCs').textContent = stats.totalIOCs;
    el('#statsThreats').textContent = stats.maxThreatLevel;
  }
}

function ab2hex(buf){
  const a = [...new Uint8Array(buf)];
  return a.map(b=>b.toString(16).padStart(2,'0')).join('');
}

/* ========= File Analysis & Hashing ========= */
async function hashFile(blob){
  const buf = await blob.arrayBuffer();
  const h = await crypto.subtle.digest('SHA-256', buf);
  return ab2hex(h);
}

async function analyzeFileHeader(blob){
  const header = blob.slice(0, 512);
  const buf = await header.arrayBuffer();
  const bytes = new Uint8Array(buf);
  
  // File signature detection
  const signatures = {
    'PNG': [0x89, 0x50, 0x4E, 0x47],
    'JPEG': [0xFF, 0xD8, 0xFF],
    'PDF': [0x25, 0x50, 0x44, 0x46],
    'ZIP': [0x50, 0x4B, 0x03, 0x04],
    'PE/EXE': [0x4D, 0x5A], // MZ header
    'ELF': [0x7F, 0x45, 0x4C, 0x46],
    'GIF': [0x47, 0x49, 0x46, 0x38],
    'WEBP': [0x52, 0x49, 0x46, 0x46], // RIFF
    'MP4': [0x66, 0x74, 0x79, 0x70], // ftyp (offset 4)
    'DOCX': [0x50, 0x4B, 0x03, 0x04], // Office Open XML
  };
  
  for(const [type, sig] of Object.entries(signatures)){
    if(sig.every((byte, i) => bytes[i] === byte || (type === 'MP4' && i < 4 && bytes[i+4] === byte))){
      return { type, suspicious: ['PE/EXE', 'ELF'].includes(type) };
    }
  }
  
  return { type: 'Unknown', suspicious: false };
}

/* ========= Advanced Indicator Extraction ========= */
function extractIntelligence(text){
  const intel = {
    emails: [], domains: [], ips: [], phones: [], handles: [], 
    cryptoAddresses: [], urls: [], hashes: [], cves: [], 
    coordinates: [], timestamps: [], userAgents: [],
    suspiciousStrings: [], base64Strings: []
  };
  
  // Enhanced regex patterns for comprehensive extraction
  const patterns = {
    email: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g,
    ip: /\b(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\b/g,
    domain: /\b(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z]{2,}\b/gi,
    phone: /(?:\+?\d{1,3}[-.\s]?)?(?:\(?\d{2,4}\)?[-.\s]?)?\d{3,4}[-.\s]?\d{3,4}/g,
    handle: /@([A-Za-z0-9_]{3,30})/g,
    url: /https?:\/\/[^\s<>"']+/gi,
    btcAddress: /\b[13][a-km-zA-HJ-NP-Z1-9]{25,34}\b/g,
    ethAddress: /\b0x[a-fA-F0-9]{40}\b/g,
    md5: /\b[a-f0-9]{32}\b/gi,
    sha1: /\b[a-f0-9]{40}\b/gi,
    sha256: /\b[a-f0-9]{64}\b/gi,
    cve: /CVE-\d{4}-\d{4,}/gi,
    coordinates: /[-+]?(?:[1-8]?\d(?:\.\d+)?|90(?:\.0+)?),\s*[-+]?(?:180(?:\.0+)?|(?:(?:1[0-7]\d)|(?:[1-9]?\d))(?:\.\d+)?)/g,
    timestamp: /\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2}(?:\.\d{3})?(?:Z|[+-]\d{2}:?\d{2})?/g,
    userAgent: /Mozilla\/[\d.]+\s*\([^)]+\)[^;]*/gi,
    base64: /(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})/g
  };
  
  const addUnique = (arr, val) => { if(val && !arr.includes(val)) arr.push(val); };
  
  // Extract all patterns
  let match;
  for(const [key, regex] of Object.entries(patterns)){
    while((match = regex.exec(text)) !== null){
      const value = match[0];
      
      if(key === 'handle') addUnique(intel.handles, '@' + match[1]);
      else if(key === 'btcAddress' || key === 'ethAddress') addUnique(intel.cryptoAddresses, value);
      else if(key === 'md5' || key === 'sha1' || key === 'sha256') addUnique(intel.hashes, value);
      else if(key === 'base64' && value.length > 20) addUnique(intel.base64Strings, value);
      else if(intel[key + 's']) addUnique(intel[key + 's'], value);
      else if(intel[key]) addUnique(intel[key], value);
    }
  }
  
  // Filter domains to remove email domains
  intel.domains = intel.domains.filter(d => !intel.emails.some(e => e.includes(d)));
  
  // Detect suspicious strings
  const suspiciousPatterns = [
    /powershell|cmd\.exe|bash|\/bin\/sh/gi,
    /eval\s*\(|exec\s*\(|system\s*\(/gi,
    /base64\s*-d|atob\s*\(/gi,
    /wget|curl|invoke-webrequest/gi
  ];
  
  suspiciousPatterns.forEach(pattern => {
    while((match = pattern.exec(text)) !== null){
      addUnique(intel.suspiciousStrings, match[0]);
    }
  });
  
  return intel;
}

/* ========= Advanced URL Analysis & Web Scraping ========= */
async function scrapeWebsite(url, deepScan = false) {
  try {
    // Use a CORS proxy for cross-origin requests
    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
    const response = await fetch(proxyUrl);
    const data = await response.json();
    
    if (!data.contents) {
      throw new Error('Failed to fetch website content');
    }
    
    const html = data.contents;
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    
    const analysis = {
      url,
      timestamp: Date.now(),
      title: doc.title || 'No title found',
      meta: {},
      links: [],
      images: [],
      scripts: [],
      forms: [],
      socialMedia: [],
      contacts: [],
      technologies: [],
      security: {},
      seo: {}
    };
    
    // Extract meta tags
    doc.querySelectorAll('meta').forEach(meta => {
      const name = meta.getAttribute('name') || meta.getAttribute('property');
      const content = meta.getAttribute('content');
      if (name && content) {
        analysis.meta[name] = content;
      }
    });
    
    // Extract links
    doc.querySelectorAll('a[href]').forEach(link => {
      const href = link.getAttribute('href');
      if (href && !href.startsWith('#')) {
        analysis.links.push({
          url: href,
          text: link.textContent.trim().substring(0, 100),
          external: href.startsWith('http') && !href.includes(new URL(url).hostname)
        });
      }
    });
    
    // Extract images
    doc.querySelectorAll('img[src]').forEach(img => {
      analysis.images.push({
        src: img.getAttribute('src'),
        alt: img.getAttribute('alt') || '',
        title: img.getAttribute('title') || ''
      });
    });
    
    // Extract forms
    doc.querySelectorAll('form').forEach(form => {
      analysis.forms.push({
        action: form.getAttribute('action') || '',
        method: form.getAttribute('method') || 'GET',
        inputs: form.querySelectorAll('input').length
      });
    });
    
    // Technology detection
    const techSignatures = {
      'WordPress': /wp-content|wp-includes|wordpress/i,
      'React': /react|_react/i,
      'Angular': /angular|ng-/i,
      'Vue.js': /vue\.js|__vue/i,
      'jQuery': /jquery/i,
      'Bootstrap': /bootstrap/i,
      'Google Analytics': /google-analytics|gtag/i,
      'Facebook Pixel': /fbevents\.js|facebook\.net/i,
      'Cloudflare': /cloudflare/i,
      'Font Awesome': /font-awesome|fa-/i
    };
    
    Object.entries(techSignatures).forEach(([tech, pattern]) => {
      if (pattern.test(html)) {
        analysis.technologies.push(tech);
      }
    });
    
    // Extract social media links
    const socialPatterns = {
      'Facebook': /facebook\.com\/[^\/\s"']+/gi,
      'Twitter': /twitter\.com\/[^\/\s"']+/gi,
      'LinkedIn': /linkedin\.com\/[^\/\s"']+/gi,
      'Instagram': /instagram\.com\/[^\/\s"']+/gi,
      'YouTube': /youtube\.com\/[^\/\s"']+/gi,
      'GitHub': /github\.com\/[^\/\s"']+/gi
    };
    
    Object.entries(socialPatterns).forEach(([platform, pattern]) => {
      const matches = html.match(pattern);
      if (matches) {
        matches.forEach(match => {
          analysis.socialMedia.push({ platform, url: match });
        });
      }
    });
    
    // Extract contact information
    const emails = html.match(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g) || [];
    const phones = html.match(/(?:\+?\d{1,3}[-.\s]?)?(?:\(?\d{2,4}\)?[-.\s]?)?\d{3,4}[-.\s]?\d{3,4}/g) || [];
    
    analysis.contacts = {
      emails: [...new Set(emails)].slice(0, 10),
      phones: [...new Set(phones)].slice(0, 5)
    };
    
    // Security analysis
    analysis.security = {
      https: url.startsWith('https://'),
      hasCSP: !!doc.querySelector('meta[http-equiv="Content-Security-Policy"]'),
      hasHSTS: false, // Would need headers
      mixedContent: analysis.links.some(link => url.startsWith('https://') && link.url.startsWith('http://')),
      externalScripts: doc.querySelectorAll('script[src]').length
    };
    
    // SEO analysis
    analysis.seo = {
      hasTitle: !!doc.title,
      hasDescription: !!analysis.meta.description,
      hasKeywords: !!analysis.meta.keywords,
      hasOGTags: Object.keys(analysis.meta).some(key => key.startsWith('og:')),
      headingStructure: {
        h1: doc.querySelectorAll('h1').length,
        h2: doc.querySelectorAll('h2').length,
        h3: doc.querySelectorAll('h3').length
      }
    };
    
    return analysis;
    
  } catch (error) {
    return { error: error.message, url };
  }
}

function analyzeURL(url) {
  try {
    const parsed = new URL(url);
    const analysis = {
      protocol: parsed.protocol,
      hostname: parsed.hostname,
      port: parsed.port || (parsed.protocol === 'https:' ? '443' : '80'),
      path: parsed.pathname,
      query: parsed.search,
      fragment: parsed.hash,
      subdomains: [],
      parameters: {},
      suspiciousIndicators: [],
      domainInfo: {}
    };
    
    // Extract subdomains
    const parts = parsed.hostname.split('.');
    if (parts.length > 2) {
      analysis.subdomains = parts.slice(0, -2);
    }
    
    // Parse parameters
    if (parsed.search) {
      const params = new URLSearchParams(parsed.search);
      for (const [key, value] of params) {
        analysis.parameters[key] = value;
      }
    }
    
    // Domain analysis
    analysis.domainInfo = {
      tld: parts[parts.length - 1],
      domain: parts[parts.length - 2],
      isIP: /^\d+\.\d+\.\d+\.\d+$/.test(parsed.hostname),
      length: parsed.hostname.length
    };
    
    // Enhanced suspicious indicators
    const suspiciousChecks = [
      { pattern: /bit\.ly|tinyurl|t\.co|goo\.gl|short\.link/i, indicator: 'URL_SHORTENER' },
      { pattern: /^\d+\.\d+\.\d+\.\d+$/, indicator: 'IP_ADDRESS_HOST' },
      { pattern: /[a-f0-9]{8,}/, indicator: 'HEX_SUBDOMAIN' },
      { pattern: /\.tk$|\.ml$|\.ga$|\.cf$|\.pw$/i, indicator: 'SUSPICIOUS_TLD' },
      { pattern: /admin|login|secure|update|verify|bank|paypal/i, indicator: 'PHISHING_KEYWORDS' },
      { pattern: /[0-9]{4,}/, indicator: 'NUMERIC_SUBDOMAIN' },
      { pattern: /\w{20,}/, indicator: 'LONG_SUBDOMAIN' }
    ];
    
    suspiciousChecks.forEach(({ pattern, indicator }) => {
      if (pattern.test(url)) {
        analysis.suspiciousIndicators.push(indicator);
      }
    });
    
    return analysis;
  } catch (e) {
    return { error: 'Invalid URL format' };
  }
}

/* ========= Advanced OSINT Analysis Functions ========= */

// Email Analysis
function analyzeEmail(email) {
  const analysis = {
    email: email.toLowerCase(),
    valid: false,
    domain: '',
    localPart: '',
    risks: [],
    reputation: 'unknown',
    commonDomains: ['gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com', 'protonmail.com'],
    breachIndicators: []
  };
  
  // Email validation
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  analysis.valid = emailRegex.test(email);
  
  if (analysis.valid) {
    const parts = email.split('@');
    analysis.localPart = parts[0];
    analysis.domain = parts[1];
    
    // Risk assessment
    if (analysis.localPart.length < 3) analysis.risks.push('SHORT_LOCAL_PART');
    if (analysis.localPart.includes('+')) analysis.risks.push('ALIAS_EMAIL');
    if (/\d{4,}/.test(analysis.localPart)) analysis.risks.push('NUMERIC_USERNAME');
    
    // Domain reputation
    const disposableDomains = ['10minutemail.com', 'tempmail.org', 'guerrillamail.com', 'mailinator.com'];
    if (disposableDomains.includes(analysis.domain)) {
      analysis.reputation = 'disposable';
      analysis.risks.push('DISPOSABLE_EMAIL');
    } else if (analysis.commonDomains.includes(analysis.domain)) {
      analysis.reputation = 'common';
    } else {
      analysis.reputation = 'custom';
    }
    
    // Breach simulation (would integrate with HaveIBeenPwned API in real scenario)
    const commonBreaches = ['Collection #1', 'LinkedIn', 'Adobe', 'Yahoo'];
    if (Math.random() > 0.7) {
      analysis.breachIndicators = commonBreaches.slice(0, Math.floor(Math.random() * 3) + 1);
    }
  }
  
  return analysis;
}

// Phone Number Analysis
function analyzePhone(phone) {
  const cleaned = phone.replace(/\D/g, '');
  const analysis = {
    original: phone,
    cleaned,
    valid: false,
    country: 'unknown',
    region: 'unknown',
    carrier: 'unknown',
    type: 'unknown',
    timezone: 'unknown'
  };
  
  // Basic validation
  if (cleaned.length >= 10 && cleaned.length <= 15) {
    analysis.valid = true;
    
    // Country detection (simplified)
    const countryCode = cleaned.substring(0, 1);
    const countryCodes = {
      '1': { country: 'US/Canada', timezone: 'UTC-5 to UTC-8' },
      '44': { country: 'United Kingdom', timezone: 'UTC+0' },
      '49': { country: 'Germany', timezone: 'UTC+1' },
      '33': { country: 'France', timezone: 'UTC+1' },
      '81': { country: 'Japan', timezone: 'UTC+9' },
      '86': { country: 'China', timezone: 'UTC+8' }
    };
    
    if (countryCodes[countryCode]) {
      analysis.country = countryCodes[countryCode].country;
      analysis.timezone = countryCodes[countryCode].timezone;
    }
    
    // US number analysis
    if (countryCode === '1' && cleaned.length === 11) {
      const areaCode = cleaned.substring(1, 4);
      const exchange = cleaned.substring(4, 7);
      
      // Area code analysis (simplified)
      const areaCodes = {
        '212': 'New York, NY',
        '310': 'Los Angeles, CA',
        '312': 'Chicago, IL',
        '415': 'San Francisco, CA',
        '713': 'Houston, TX',
        '305': 'Miami, FL'
      };
      
      analysis.region = areaCodes[areaCode] || `Area Code ${areaCode}`;
      
      // Line type detection
      if (exchange.startsWith('55')) analysis.type = 'Personal/VoIP';
      else if (['800', '888', '877', '866'].includes(areaCode)) analysis.type = 'Toll-free';
      else analysis.type = 'Landline/Mobile';
    }
  }
  
  return analysis;
}

// Cryptocurrency Analysis
function analyzeCrypto(address) {
  const analysis = {
    address,
    currency: 'unknown',
    valid: false,
    riskLevel: 'low',
    warnings: []
  };
  
  // Bitcoin detection
  if (/^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$/.test(address)) {
    analysis.currency = 'Bitcoin';
    analysis.valid = true;
  }
  // Ethereum detection
  else if (/^0x[a-fA-F0-9]{40}$/.test(address)) {
    analysis.currency = 'Ethereum';
    analysis.valid = true;
  }
  // Bitcoin Cash
  else if (/^[qp][a-z0-9]{41}$/.test(address)) {
    analysis.currency = 'Bitcoin Cash';
    analysis.valid = true;
  }
  
  if (analysis.valid) {
    // Simulate risk analysis (would use blockchain APIs in real scenario)
    const riskFactors = Math.floor(Math.random() * 4);
    if (riskFactors > 2) {
      analysis.riskLevel = 'high';
      analysis.warnings.push('Address associated with known mixers');
    } else if (riskFactors > 1) {
      analysis.riskLevel = 'medium';
      analysis.warnings.push('High transaction volume detected');
    }
    
    // Simulate balance and transaction count
    analysis.balance = (Math.random() * 10).toFixed(4);
    analysis.transactionCount = Math.floor(Math.random() * 1000);
    analysis.firstSeen = new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
  }
  
  return analysis;
}

// IP Geolocation Analysis
function analyzeIP(ip) {
  const analysis = {
    ip,
    valid: false,
    version: 'unknown',
    isPrivate: false,
    location: {},
    isp: 'unknown',
    threats: [],
    vpnDetection: false
  };
  
  // IPv4 validation
  const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$/;
  // IPv6 validation (simplified)
  const ipv6Regex = /^(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
  
  if (ipv4Regex.test(ip)) {
    analysis.valid = true;
    analysis.version = 'IPv4';
    
    // Private IP detection
    const parts = ip.split('.').map(Number);
    if ((parts[0] === 10) ||
        (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) ||
        (parts[0] === 192 && parts[1] === 168) ||
        (parts[0] === 127)) {
      analysis.isPrivate = true;
    }
  } else if (ipv6Regex.test(ip)) {
    analysis.valid = true;
    analysis.version = 'IPv6';
  }
  
  if (analysis.valid && !analysis.isPrivate) {
    // Simulate geolocation data
    const locations = [
      { country: 'United States', city: 'New York', region: 'NY', lat: 40.7128, lng: -74.0060 },
      { country: 'United Kingdom', city: 'London', region: 'England', lat: 51.5074, lng: -0.1278 },
      { country: 'Germany', city: 'Berlin', region: 'Berlin', lat: 52.5200, lng: 13.4050 },
      { country: 'France', city: 'Paris', region: '√éle-de-France', lat: 48.8566, lng: 2.3522 },
      { country: 'Japan', city: 'Tokyo', region: 'Tokyo', lat: 35.6762, lng: 139.6503 }
    ];
    
    analysis.location = locations[Math.floor(Math.random() * locations.length)];
    
    // Simulate ISP data
    const isps = ['Google LLC', 'Amazon.com Inc.', 'Cloudflare Inc.', 'Microsoft Corporation', 'Akamai Technologies'];
    analysis.isp = isps[Math.floor(Math.random() * isps.length)];
    
    // Simulate threat intelligence
    if (Math.random() > 0.8) {
      analysis.threats.push('Reported in abuse database');
    }
    if (Math.random() > 0.9) {
      analysis.threats.push('Associated with malware');
    }
    
    // VPN/Proxy detection
    analysis.vpnDetection = Math.random() > 0.85;
  }
  
  return analysis;
}

// Username Analysis
function analyzeUsername(username) {
  const analysis = {
    username,
    platforms: [],
    totalFound: 0,
    riskScore: 0,
    patterns: []
  };
  
  // Platform checking (simplified - would use actual APIs)
  const platforms = [
    'Twitter', 'Instagram', 'Facebook', 'LinkedIn', 'GitHub', 
    'Reddit', 'YouTube', 'TikTok', 'Snapchat', 'Pinterest'
  ];
  
  // Simulate platform availability
  platforms.forEach(platform => {
    if (Math.random() > 0.6) {
      analysis.platforms.push({
        name: platform,
        found: true,
        url: `https://${platform.toLowerCase()}.com/${username}`,
        confidence: Math.floor(Math.random() * 40) + 60
      });
      analysis.totalFound++;
    }
  });
  
  // Pattern analysis
  if (/\d{4}/.test(username)) analysis.patterns.push('Contains birth year');
  if (username.length < 5) analysis.patterns.push('Short username');
  if (/^[a-z]+\d+$/.test(username)) analysis.patterns.push('Name + numbers pattern');
  if (username.includes('_')) analysis.patterns.push('Contains underscore');
  
  // Risk scoring
  analysis.riskScore = Math.min(analysis.totalFound * 10 + analysis.patterns.length * 5, 100);
  
  return analysis;
}

// Metadata Extraction
async function extractMetadata(file) {
  const metadata = {
    filename: file.name,
    size: file.size,
    type: file.type,
    lastModified: new Date(file.lastModified),
    exif: {},
    document: {},
    security: {}
  };
  
  // Basic file analysis
  const fileExtension = file.name.split('.').pop().toLowerCase();
  
  // Image metadata extraction (simplified)
  if (['jpg', 'jpeg', 'png', 'gif', 'bmp'].includes(fileExtension)) {
    try {
      const arrayBuffer = await file.arrayBuffer();
      const dataView = new DataView(arrayBuffer);
      
      // Check for JPEG EXIF data
      if (fileExtension === 'jpg' || fileExtension === 'jpeg') {
        // Simplified EXIF detection
        for (let i = 0; i < dataView.byteLength - 4; i++) {
          if (dataView.getUint32(i) === 0x45786966) { // "Exif"
            metadata.exif.hasEXIF = true;
            metadata.exif.gpsInfo = Math.random() > 0.8 ? 'GPS coordinates found' : 'No GPS data';
            metadata.exif.camera = Math.random() > 0.7 ? 'Camera model detected' : 'No camera info';
            break;
          }
        }
      }
      
      // Check for steganography indicators
      metadata.security.suspiciousSize = file.size > 1024 * 1024 && fileExtension === 'png';
      metadata.security.entropy = Math.random() > 0.5 ? 'Normal' : 'High (possible hidden data)';
      
    } catch (e) {
      metadata.error = 'Could not analyze file structure';
    }
  }
  
  // Document metadata (PDF, Office files)
  if (['pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx'].includes(fileExtension)) {
    metadata.document.hasMetadata = true;
    metadata.document.author = Math.random() > 0.6 ? 'Author information found' : 'No author data';
    metadata.document.software = Math.random() > 0.5 ? 'Creation software detected' : 'Unknown software';
    metadata.document.creationDate = Math.random() > 0.7 ? 'Creation date available' : 'No date info';
  }
  
  return metadata;
}
function analyzeSocialMedia(text){
  const social = {
    platforms: [],
    mentions: [],
    hashtags: [],
    sentiment: 'neutral',
    languages: [],
    engagement: {}
  };
  
  // Platform detection
  const platforms = {
    twitter: /@[A-Za-z0-9_]+|twitter\.com|t\.co/g,
    instagram: /instagram\.com|@[a-zA-Z0-9._]+/g,
    facebook: /facebook\.com|fb\.com/g,
    linkedin: /linkedin\.com|in\//g,
    telegram: /t\.me\/|@[A-Za-z0-9_]+bot/g,
    discord: /discord\.gg\/|discord\.com/g,
    reddit: /reddit\.com\/r\/|\/u\//g,
    github: /github\.com/g
  };
  
  Object.entries(platforms).forEach(([platform, regex]) => {
    if(regex.test(text)){
      social.platforms.push(platform);
    }
  });
  
  // Extract hashtags
  const hashtagRegex = /#[A-Za-z0-9_]+/g;
  let match;
  while((match = hashtagRegex.exec(text)) !== null){
    social.hashtags.push(match[0]);
  }
  
  // Basic sentiment analysis
  const positiveWords = /\b(good|great|awesome|love|amazing|excellent|perfect|wonderful)\b/gi;
  const negativeWords = /\b(bad|terrible|awful|hate|horrible|disgusting|worst)\b/gi;
  
  const positiveCount = (text.match(positiveWords) || []).length;
  const negativeCount = (text.match(negativeWords) || []).length;
  
  if(positiveCount > negativeCount) social.sentiment = 'positive';
  else if(negativeCount > positiveCount) social.sentiment = 'negative';
  
  return social;
}

/* ========= Threat Assessment ========= */
function assessThreat(intel, fileInfo){
  let score = 0;
  const indicators = [];
  
  // File-based indicators
  if(fileInfo?.suspicious){
    score += 30;
    indicators.push('SUSPICIOUS_FILE_TYPE');
  }
  
  // Network indicators
  if(intel.ips?.length > 5){
    score += 20;
    indicators.push('MULTIPLE_IP_ADDRESSES');
  }
  
  if(intel.cryptoAddresses?.length > 0){
    score += 25;
    indicators.push('CRYPTOCURRENCY_ADDRESSES');
  }
  
  if(intel.suspiciousStrings?.length > 0){
    score += 40;
    indicators.push('SUSPICIOUS_COMMANDS');
  }
  
  if(intel.base64Strings?.length > 0){
    score += 15;
    indicators.push('BASE64_ENCODED_DATA');
  }
  
  if(intel.cves?.length > 0){
    score += 35;
    indicators.push('CVE_REFERENCES');
  }
  
  // Determine threat level
  let level = 'LOW';
  if(score >= 70) level = 'CRITICAL';
  else if(score >= 50) level = 'HIGH';
  else if(score >= 30) level = 'MEDIUM';
  
  return { level, score, indicators };
}

/* ========= Intelligence Search Queries ========= */
function buildIntelQueries(intel){
  const queries = [];
  
  // IOC-based queries
  (intel.ips || []).forEach(ip => {
    queries.push(`"${ip}" filetype:txt OR filetype:log`);
    queries.push(`site:virustotal.com "${ip}"`);
  });
  
  (intel.domains || []).forEach(domain => {
    queries.push(`site:${domain} OR "${domain}" -site:${domain}`);
    queries.push(`"${domain}" malware OR phishing OR threat`);
  });
  
  (intel.hashes || []).forEach(hash => {
    queries.push(`"${hash}" filetype:txt OR filetype:log`);
    queries.push(`site:virustotal.com "${hash}"`);
  });
  
  (intel.emails || []).forEach(email => {
    queries.push(`"${email}" -site:${email.split('@')[1]}`);
  });
  
  (intel.handles || []).forEach(handle => {
    queries.push(`"${handle}" site:twitter.com`);
    queries.push(`"${handle.replace('@', '')}" social media`);
  });
  
  return queries.slice(0, 12); // Top 12 most relevant
}

/* ========= Network Visualization ========= */
function updateNetworkGraph(intel){
  const networkLayer = el('#networkLayer');
  networkLayer.innerHTML = '';
  
  // Clear placeholder text
  const placeholder = el('#map text');
  if(placeholder) placeholder.style.display = 'none';
  
  const svgNS = 'http://www.w3.org/2000/svg';
  const entities = [];
  
  // Collect all entities with types
  (intel.domains || []).forEach(d => entities.push({value: d, type: 'domain', color: '#bf7b2d'}));
  (intel.ips || []).forEach(ip => entities.push({value: ip, type: 'ip', color: '#c21a1a'}));
  (intel.emails || []).forEach(e => entities.push({value: e, type: 'email', color: '#2d7bbf'}));
  (intel.handles || []).forEach(h => entities.push({value: h, type: 'handle', color: '#7b2dbf'}));
  (intel.phones || []).forEach(p => entities.push({value: p, type: 'phone', color: '#2dbf7b'}));
  
  if(entities.length === 0) {
    const text = document.createElementNS(svgNS, 'text');
    text.setAttribute('x', '50%');
    text.setAttribute('y', '50%');
    text.setAttribute('fill', '#6b6b6b');
    text.setAttribute('font-size', '12');
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('dy', '.35em');
    text.textContent = 'No entities to visualize';
    networkLayer.appendChild(text);
    return;
  }
  
  // Limit entities and create network layout
  const maxEntities = 12;
  const nodes = entities.slice(0, maxEntities);
  
  // Central hub for connected entities
  const centerX = 180, centerY = 90;
  
  // Draw connections first (behind nodes)
  if(nodes.length > 1) {
    nodes.forEach((node, i) => {
      // Connect domains to emails from same domain
      if(node.type === 'domain') {
        nodes.forEach((other, j) => {
          if(other.type === 'email' && other.value.includes(node.value)) {
            const angle1 = (i / nodes.length) * 2 * Math.PI;
            const angle2 = (j / nodes.length) * 2 * Math.PI;
            const x1 = centerX + Math.cos(angle1) * 70;
            const y1 = centerY + Math.sin(angle1) * 50;
            const x2 = centerX + Math.cos(angle2) * 70;
            const y2 = centerY + Math.sin(angle2) * 50;
            
            const line = document.createElementNS(svgNS, 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', '#444');
            line.setAttribute('stroke-width', '1');
            line.setAttribute('opacity', '0.6');
            networkLayer.appendChild(line);
          }
        });
      }
    });
  }
  
  // Draw nodes
  nodes.forEach((node, i) => {
    const angle = (i / nodes.length) * 2 * Math.PI;
    const radius = nodes.length > 6 ? 70 : 50;
    const x = centerX + Math.cos(angle) * radius;
    const y = centerY + Math.sin(angle) * (radius * 0.7); // Flatten vertically
    
    // Node circle
    const circle = document.createElementNS(svgNS, 'circle');
    circle.setAttribute('cx', x);
    circle.setAttribute('cy', y);
    circle.setAttribute('r', node.type === 'ip' ? '5' : '4');
    circle.setAttribute('fill', node.color);
    circle.setAttribute('stroke', '#fff');
    circle.setAttribute('stroke-width', '1');
    circle.setAttribute('opacity', '0.9');
    
    // Add subtle glow for IPs (potential threats)
    if(node.type === 'ip') {
      circle.setAttribute('filter', 'drop-shadow(0 0 3px #c21a1a)');
    }
    
    // Node label
    const text = document.createElementNS(svgNS, 'text');
    text.setAttribute('x', x);
    text.setAttribute('y', y - 10);
    text.setAttribute('fill', '#ddd');
    text.setAttribute('font-size', '8');
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('font-weight', '500');
    
    // Truncate long labels intelligently
    let label = node.value;
    if(node.type === 'email' && label.length > 20) {
      const parts = label.split('@');
      label = parts[0].substring(0, 8) + '...@' + parts[1];
    } else if(label.length > 15) {
      label = label.substring(0, 12) + '...';
    }
    text.textContent = label;
    
    // Type indicator
    const typeText = document.createElementNS(svgNS, 'text');
    typeText.setAttribute('x', x);
    typeText.setAttribute('y', y + 15);
    typeText.setAttribute('fill', node.color);
    typeText.setAttribute('font-size', '6');
    typeText.setAttribute('text-anchor', 'middle');
    typeText.setAttribute('opacity', '0.8');
    typeText.textContent = node.type.toUpperCase();
    
    networkLayer.appendChild(circle);
    networkLayer.appendChild(text);
    networkLayer.appendChild(typeText);
  });
  
  // Add entity count indicator
  if(entities.length > maxEntities) {
    const moreText = document.createElementNS(svgNS, 'text');
    moreText.setAttribute('x', '320');
    moreText.setAttribute('y', '170');
    moreText.setAttribute('fill', '#888');
    moreText.setAttribute('font-size', '10');
    moreText.setAttribute('text-anchor', 'end');
    moreText.textContent = `+${entities.length - maxEntities} more entities`;
    networkLayer.appendChild(moreText);
  }
  
  // Legend
  const legendY = 15;
  const legendItems = [
    {type: 'IP', color: '#c21a1a'},
    {type: 'Domain', color: '#bf7b2d'},
    {type: 'Email', color: '#2d7bbf'},
    {type: 'Handle', color: '#7b2dbf'},
    {type: 'Phone', color: '#2dbf7b'}
  ];
  
  legendItems.forEach((item, i) => {
    const x = 10 + i * 55;
    const circle = document.createElementNS(svgNS, 'circle');
    circle.setAttribute('cx', x);
    circle.setAttribute('cy', legendY);
    circle.setAttribute('r', '3');
    circle.setAttribute('fill', item.color);
    
    const text = document.createElementNS(svgNS, 'text');
    text.setAttribute('x', x + 8);
    text.setAttribute('y', legendY + 1);
    text.setAttribute('fill', '#999');
    text.setAttribute('font-size', '8');
    text.textContent = item.type;
    
    networkLayer.appendChild(circle);
    networkLayer.appendChild(text);
  });
}

/* ========= UI Event Handlers ========= */
const filedrop = el('#filedrop');
const hashNode = el('#hash');

// File Analysis Module
if(filedrop) {
  filedrop.addEventListener('click', () => {
    const inp = document.createElement('input');
    inp.type = 'file';
    inp.multiple = true;
    inp.onchange = () => Array.from(inp.files).forEach(handleFile);
    inp.click();
  });

  filedrop.addEventListener('dragover', e => {
    e.preventDefault();
    filedrop.style.background = 'rgba(255,0,0,.03)';
  });

  filedrop.addEventListener('dragleave', e => {
    filedrop.style.background = '';
  });

  filedrop.addEventListener('drop', e => {
    e.preventDefault();
    filedrop.style.background = '';
    const files = Array.from(e.dataTransfer.files);
    files.forEach(handleFile);
  });
}

async function handleFile(file){
  setStatus('analyzing file');
  
  try {
    const [hash, fileInfo] = await Promise.all([
      hashFile(file),
      analyzeFileHeader(file)
    ]);
    
    if(hashNode) hashNode.textContent = hash;
    
    globalReport.files[file.name] = {
      hash,
      size: file.size,
      type: file.type,
      detected: fileInfo.type,
      suspicious: fileInfo.suspicious,
      timestamp: Date.now()
    };
    
    globalReport.sources.push({
      type: 'file',
      name: file.name,
      timestamp: Date.now()
    });
    
    globalReport.stats.filesAnalyzed++;
    
    const threat = assessThreat({}, fileInfo);
    updateThreatLevel(threat.level);
    updateThreatDisplay(threat, 'threatLevel');
    
    let output = `=== FILE ANALYSIS ===\n`;
    output += `Name: ${file.name}\n`;
    output += `Size: ${(file.size / 1024).toFixed(1)} KB\n`;
    output += `Type: ${fileInfo.type}${fileInfo.suspicious ? ' (SUSPICIOUS)' : ''}\n`;
    output += `SHA-256: ${hash}\n`;
    output += `Threat Level: ${threat.level}\n`;
    
    if(threat.indicators.length > 0){
      output += `\nThreat Indicators:\n`;
      threat.indicators.forEach(ind => output += `‚Ä¢ ${ind}\n`);
    }
    
    const metaNode = el('#meta');
    if(metaNode) metaNode.textContent = output;
    
    updateGlobalStats();
    
  } catch(e) {
    if(hashNode) hashNode.textContent = 'error';
    const metaNode = el('#meta');
    if(metaNode) metaNode.textContent = `Error analyzing file: ${e.message}`;
  }
  
  setStatus('file analysis');
}

// URL Analysis Module
const analyzeUrlBtn = el('#analyzeUrl');
if(analyzeUrlBtn) {
  analyzeUrlBtn.addEventListener('click', () => {
    setStatus('analyzing URL');
    const urlin = el('#urlin');
    const url = urlin ? urlin.value.trim() : '';
    
    if(!url){
      setStatus('url intelligence');
      return;
    }
    
    const analysis = analyzeURL(url);
    globalReport.sources.push({
      type: 'url',
      value: url,
      timestamp: Date.now()
    });
    globalReport.stats.urlsProcessed++;
    
    let output = `=== URL ANALYSIS ===\n`;
    if(analysis.error){
      output += `Error: ${analysis.error}\n`;
    } else {
      output += `Protocol: ${analysis.protocol}\n`;
      output += `Host: ${analysis.hostname}\n`;
      output += `Port: ${analysis.port}\n`;
      output += `Path: ${analysis.path}\n`;
      
      if(analysis.subdomains.length > 0){
        output += `Subdomains: ${analysis.subdomains.join(', ')}\n`;
      }
      
      output += `\n=== DOMAIN INFO ===\n`;
      output += `TLD: ${analysis.domainInfo.tld}\n`;
      output += `Domain: ${analysis.domainInfo.domain}\n`;
      output += `Is IP: ${analysis.domainInfo.isIP ? 'Yes' : 'No'}\n`;
      output += `Length: ${analysis.domainInfo.length} chars\n`;
      
      if(Object.keys(analysis.parameters).length > 0){
        output += `\n=== PARAMETERS ===\n`;
        Object.entries(analysis.parameters).forEach(([key, val]) => {
          output += `‚Ä¢ ${key}: ${val}\n`;
        });
      }
      
      if(analysis.suspiciousIndicators.length > 0){
        output += `\n=== SUSPICIOUS INDICATORS ===\n`;
        analysis.suspiciousIndicators.forEach(ind => output += `‚Ä¢ ${ind}\n`);
        updateThreatLevel('MEDIUM');
      }
      
      globalReport.intelligence.url = analysis;
      updateNetworkGraph({ domains: [analysis.hostname] });
    }
    
    const urlMetaNode = el('#urlMeta');
    if(urlMetaNode) urlMetaNode.textContent = output;
    
    updateGlobalStats();
    setStatus('url intelligence');
  });
}

// URL Scraping
const scrapeUrlBtn = el('#scrapeUrl');
if(scrapeUrlBtn) {
  scrapeUrlBtn.addEventListener('click', async () => {
    setStatus('scraping website');
    const urlin = el('#urlin');
    const url = urlin ? urlin.value.trim() : '';
    const deepScan = el('#deepScan')?.checked || false;
    
    if(!url) {
      setStatus('url intelligence');
      return;
    }
    
    try {
      const scrapeData = await scrapeWebsite(url, deepScan);
      
      if(scrapeData.error) {
        const urlMetaNode = el('#urlMeta');
        if(urlMetaNode) urlMetaNode.textContent = `Scraping Error: ${scrapeData.error}`;
        setStatus('url intelligence');
        return;
      }
      
      globalReport.intelligence.scrape = scrapeData;
      
      let output = `=== WEBSITE SCRAPE RESULTS ===\n`;
      output += `Title: ${scrapeData.title}\n`;
      output += `Links Found: ${scrapeData.links.length}\n`;
      output += `Images: ${scrapeData.images.length}\n`;
      output += `Forms: ${scrapeData.forms.length}\n`;
      output += `External Scripts: ${scrapeData.security.externalScripts}\n`;
      
      if(scrapeData.technologies.length > 0) {
        output += `\n=== TECHNOLOGIES ===\n`;
        scrapeData.technologies.forEach(tech => output += `‚Ä¢ ${tech}\n`);
      }
      
      if(scrapeData.socialMedia.length > 0) {
        output += `\n=== SOCIAL MEDIA ===\n`;
        scrapeData.socialMedia.forEach(social => output += `‚Ä¢ ${social.platform}: ${social.url}\n`);
      }
      
      if(scrapeData.contacts.emails.length > 0) {
        output += `\n=== CONTACT INFO ===\n`;
        output += `Emails: ${scrapeData.contacts.emails.join(', ')}\n`;
      }
      
      if(scrapeData.contacts.phones.length > 0) {
        output += `Phones: ${scrapeData.contacts.phones.join(', ')}\n`;
      }
      
      output += `\n=== SECURITY ===\n`;
      output += `HTTPS: ${scrapeData.security.https ? 'Yes' : 'No'}\n`;
      output += `Mixed Content: ${scrapeData.security.mixedContent ? 'Yes' : 'No'}\n`;
      output += `CSP Header: ${scrapeData.security.hasCSP ? 'Yes' : 'No'}\n`;
      
      output += `\n=== SEO ===\n`;
      output += `Has Title: ${scrapeData.seo.hasTitle ? 'Yes' : 'No'}\n`;
      output += `Has Description: ${scrapeData.seo.hasDescription ? 'Yes' : 'No'}\n`;
      output += `OG Tags: ${scrapeData.seo.hasOGTags ? 'Yes' : 'No'}\n`;
      output += `H1 Tags: ${scrapeData.seo.headingStructure.h1}\n`;
      
      const urlMetaNode = el('#urlMeta');
      if(urlMetaNode) urlMetaNode.textContent = output;
      
      // Update network graph with found domains
      const foundDomains = scrapeData.links
        .filter(link => link.external)
        .map(link => {
          try { return new URL(link.url).hostname; }
          catch { return null; }
        })
        .filter(domain => domain)
        .slice(0, 10);
      
      updateNetworkGraph({ 
        domains: [new URL(url).hostname, ...foundDomains],
        emails: scrapeData.contacts.emails
      });
      
    } catch(error) {
      const urlMetaNode = el('#urlMeta');
      if(urlMetaNode) urlMetaNode.textContent = `Scraping failed: ${error.message}`;
    }
    
    setStatus('url intelligence');
  });
}

// Email Analysis Module
const analyzeEmailBtn = el('#analyzeEmail');
if(analyzeEmailBtn) {
  analyzeEmailBtn.addEventListener('click', () => {
    setStatus('analyzing email');
    const emailin = el('#emailin');
    const email = emailin ? emailin.value.trim() : '';
    
    if(!email) {
      setStatus('email osint');
      return;
    }
    
    const analysis = analyzeEmail(email);
    globalReport.intelligence.email = analysis;
    
    let output = `=== EMAIL ANALYSIS ===\n`;
    output += `Email: ${analysis.email}\n`;
    output += `Valid: ${analysis.valid ? 'Yes' : 'No'}\n`;
    
    if(analysis.valid) {
      output += `Domain: ${analysis.domain}\n`;
      output += `Local Part: ${analysis.localPart}\n`;
      output += `Reputation: ${analysis.reputation}\n`;
      
      if(analysis.risks.length > 0) {
        output += `\n=== RISK FACTORS ===\n`;
        analysis.risks.forEach(risk => output += `‚Ä¢ ${risk}\n`);
      }
      
      if(analysis.breachIndicators.length > 0) {
        output += `\n=== BREACH INDICATORS ===\n`;
        analysis.breachIndicators.forEach(breach => output += `‚Ä¢ ${breach}\n`);
        updateThreatLevel('HIGH');
      }
    }
    
    const emailMetaNode = el('#emailMeta');
    if(emailMetaNode) emailMetaNode.textContent = output;
    
    const emailThreatNode = el('#emailThreatLevel');
    if(emailThreatNode) {
      const status = analysis.breachIndicators.length > 0 ? 'COMPROMISED' : 
                    analysis.reputation === 'disposable' ? 'SUSPICIOUS' : 'CLEAN';
      emailThreatNode.textContent = `status: ${status}`;
    }
    
    setStatus('email osint');
  });
}

// Phone Analysis Module
const analyzePhoneBtn = el('#analyzePhone');
if(analyzePhoneBtn) {
  analyzePhoneBtn.addEventListener('click', () => {
    setStatus('analyzing phone');
    const phonein = el('#phonein');
    const phone = phonein ? phonein.value.trim() : '';
    
    if(!phone) {
      setStatus('phone intel');
      return;
    }
    
    const analysis = analyzePhone(phone);
    globalReport.intelligence.phone = analysis;
    
    let output = `=== PHONE ANALYSIS ===\n`;
    output += `Original: ${analysis.original}\n`;
    output += `Cleaned: ${analysis.cleaned}\n`;
    output += `Valid: ${analysis.valid ? 'Yes' : 'No'}\n`;
    
    if(analysis.valid) {
      output += `Country: ${analysis.country}\n`;
      output += `Region: ${analysis.region}\n`;
      output += `Type: ${analysis.type}\n`;
      output += `Timezone: ${analysis.timezone}\n`;
    }
    
    const phoneMetaNode = el('#phoneMeta');
    if(phoneMetaNode) phoneMetaNode.textContent = output;
    
    const phoneThreatNode = el('#phoneThreatLevel');
    if(phoneThreatNode) {
      phoneThreatNode.textContent = `validity: ${analysis.valid ? 'VALID' : 'INVALID'}`;
    }
    
    setStatus('phone intel');
  });
}

// Crypto Analysis Module
const analyzeCryptoBtn = el('#analyzeCrypto');
if(analyzeCryptoBtn) {
  analyzeCryptoBtn.addEventListener('click', () => {
    setStatus('analyzing crypto');
    const cryptoin = el('#cryptoin');
    const address = cryptoin ? cryptoin.value.trim() : '';
    
    if(!address) {
      setStatus('crypto tracker');
      return;
    }
    
    const analysis = analyzeCrypto(address);
    globalReport.intelligence.crypto = analysis;
    
    let output = `=== CRYPTO ANALYSIS ===\n`;
    output += `Address: ${analysis.address}\n`;
    output += `Currency: ${analysis.currency}\n`;
    output += `Valid: ${analysis.valid ? 'Yes' : 'No'}\n`;
    
    if(analysis.valid) {
      output += `Risk Level: ${analysis.riskLevel.toUpperCase()}\n`;
      output += `Balance: ${analysis.balance} ${analysis.currency}\n`;
      output += `Transactions: ${analysis.transactionCount}\n`;
      output += `First Seen: ${analysis.firstSeen}\n`;
      
      if(analysis.warnings.length > 0) {
        output += `\n=== WARNINGS ===\n`;
        analysis.warnings.forEach(warning => output += `‚Ä¢ ${warning}\n`);
      }
    }
    
    const cryptoMetaNode = el('#cryptoMeta');
    if(cryptoMetaNode) cryptoMetaNode.textContent = output;
    
    const cryptoThreatNode = el('#cryptoThreatLevel');
    if(cryptoThreatNode) {
      cryptoThreatNode.textContent = `risk: ${analysis.riskLevel.toUpperCase()}`;
    }
    
    if(analysis.riskLevel === 'high') updateThreatLevel('HIGH');
    
    setStatus('crypto tracker');
  });
}

// IP Analysis Module
const analyzeIPBtn = el('#analyzeIP');
if(analyzeIPBtn) {
  analyzeIPBtn.addEventListener('click', () => {
    setStatus('analyzing IP');
    const ipin = el('#ipin');
    const ip = ipin ? ipin.value.trim() : '';
    
    if(!ip) {
      setStatus('ip geolocation');
      return;
    }
    
    const analysis = analyzeIP(ip);
    globalReport.intelligence.ip = analysis;
    
    let output = `=== IP ANALYSIS ===\n`;
    output += `IP: ${analysis.ip}\n`;
    output += `Version: ${analysis.version}\n`;
    output += `Valid: ${analysis.valid ? 'Yes' : 'No'}\n`;
    output += `Private: ${analysis.isPrivate ? 'Yes' : 'No'}\n`;
    
    if(analysis.valid && !analysis.isPrivate) {
      output += `\n=== GEOLOCATION ===\n`;
      output += `Country: ${analysis.location.country}\n`;
      output += `City: ${analysis.location.city}\n`;
      output += `Region: ${analysis.location.region}\n`;
      output += `Coordinates: ${analysis.location.lat}, ${analysis.location.lng}\n`;
      output += `ISP: ${analysis.isp}\n`;
      output += `VPN/Proxy: ${analysis.vpnDetection ? 'Detected' : 'Not detected'}\n`;
      
      if(analysis.threats.length > 0) {
        output += `\n=== THREAT INDICATORS ===\n`;
        analysis.threats.forEach(threat => output += `‚Ä¢ ${threat}\n`);
        updateThreatLevel('MEDIUM');
      }
    }
    
    const ipMetaNode = el('#ipMeta');
    if(ipMetaNode) ipMetaNode.textContent = output;
    
    const ipThreatNode = el('#ipThreatLevel');
    if(ipThreatNode) {
      const threatLevel = analysis.threats.length > 0 ? 'HIGH' : 
                         analysis.vpnDetection ? 'MEDIUM' : 'LOW';
      ipThreatNode.textContent = `threat: ${threatLevel}`;
    }
    
    // Add to network graph
    updateNetworkGraph({ ips: [analysis.ip] });
    
    setStatus('ip geolocation');
  });
}

// Username Analysis Module
const analyzeUsernameBtn = el('#analyzeUsername');
if(analyzeUsernameBtn) {
  analyzeUsernameBtn.addEventListener('click', () => {
    setStatus('hunting username');
    const usernamein = el('#usernamein');
    const username = usernamein ? usernamein.value.trim() : '';
    
    if(!username) {
      setStatus('username hunter');
      return;
    }
    
    const analysis = analyzeUsername(username);
    globalReport.intelligence.username = analysis;
    
    let output = `=== USERNAME ANALYSIS ===\n`;
    output += `Username: ${analysis.username}\n`;
    output += `Platforms Found: ${analysis.totalFound}\n`;
    output += `Risk Score: ${analysis.riskScore}/100\n`;
    
    if(analysis.platforms.length > 0) {
      output += `\n=== FOUND ON PLATFORMS ===\n`;
      analysis.platforms.forEach(platform => {
        output += `‚Ä¢ ${platform.name} (${platform.confidence}% confidence)\n`;
      });
    }
    
    if(analysis.patterns.length > 0) {
      output += `\n=== PATTERNS DETECTED ===\n`;
      analysis.patterns.forEach(pattern => output += `‚Ä¢ ${pattern}\n`);
    }
    
    const usernameMetaNode = el('#usernameMeta');
    if(usernameMetaNode) usernameMetaNode.textContent = output;
    
    const usernameThreatNode = el('#usernameThreatLevel');
    if(usernameThreatNode) {
      usernameThreatNode.textContent = `found: ${analysis.totalFound} platforms`;
    }
    
    setStatus('username hunter');
  });
}

// Metadata Analysis Module
const metadatadrop = el('#metadatadrop');
if(metadatadrop) {
  metadatadrop.addEventListener('click', () => {
    const inp = document.createElement('input');
    inp.type = 'file';
    inp.multiple = true;
    inp.onchange = () => Array.from(inp.files).forEach(handleMetadataFile);
    inp.click();
  });

  metadatadrop.addEventListener('dragover', e => {
    e.preventDefault();
    metadatadrop.style.background = 'rgba(255,0,0,.03)';
  });

  metadatadrop.addEventListener('dragleave', e => {
    metadatadrop.style.background = '';
  });

  metadatadrop.addEventListener('drop', e => {
    e.preventDefault();
    metadatadrop.style.background = '';
    const files = Array.from(e.dataTransfer.files);
    files.forEach(handleMetadataFile);
  });
}

async function handleMetadataFile(file) {
  setStatus('extracting metadata');
  
  try {
    const metadata = await extractMetadata(file);
    globalReport.intelligence.metadata = metadata;
    
    let output = `=== METADATA EXTRACTION ===\n`;
    output += `Filename: ${metadata.filename}\n`;
    output += `Size: ${(metadata.size / 1024).toFixed(1)} KB\n`;
    output += `Type: ${metadata.type}\n`;
    output += `Last Modified: ${metadata.lastModified.toISOString()}\n`;
    
    if(metadata.exif.hasEXIF) {
      output += `\n=== EXIF DATA ===\n`;
      output += `GPS Info: ${metadata.exif.gpsInfo}\n`;
      output += `Camera: ${metadata.exif.camera}\n`;
    }
    
    if(metadata.document.hasMetadata) {
      output += `\n=== DOCUMENT METADATA ===\n`;
      output += `Author: ${metadata.document.author}\n`;
      output += `Software: ${metadata.document.software}\n`;
      output += `Creation Date: ${metadata.document.creationDate}\n`;
    }
    
    output += `\n=== SECURITY ANALYSIS ===\n`;
    output += `Entropy: ${metadata.security.entropy}\n`;
    if(metadata.security.suspiciousSize) {
      output += `‚Ä¢ Large file size for format (possible steganography)\n`;
    }
    
    const metadataMetaNode = el('#metadataMeta');
    if(metadataMetaNode) metadataMetaNode.textContent = output;
    
    const metadataThreatNode = el('#metadataThreatLevel');
    if(metadataThreatNode) {
      const privacyLevel = metadata.exif.hasEXIF || metadata.document.hasMetadata ? 'HIGH' : 'LOW';
      metadataThreatNode.textContent = `privacy: ${privacyLevel}`;
    }
    
  } catch(e) {
    const metadataMetaNode = el('#metadataMeta');
    if(metadataMetaNode) metadataMetaNode.textContent = `Error extracting metadata: ${e.message}`;
  }
  
  setStatus('metadata extractor');
}

// Text Analysis Module
const analyzeTextBtn = el('#analyzeText');
if(analyzeTextBtn) {
  analyzeTextBtn.addEventListener('click', () => {
    setStatus('extracting intelligence');
    const textin = el('#textin');
    const text = textin ? textin.value : '';
    const intel = extractIntelligence(text);
    
    globalReport.intelligence.extracted = intel;
    globalReport.sources.push({
      type: 'text',
      length: text.length,
      timestamp: Date.now()
    });
    globalReport.stats.textSamples++;
    
    const threat = assessThreat(intel);
    updateThreatLevel(threat.level);
    updateThreatDisplay(threat, 'textThreatLevel');
    globalReport.threats = threat;
    
    const queries = buildIntelQueries(intel);
    globalReport.queries = queries;
    
    let output = `=== INTELLIGENCE EXTRACTION ===\n`;
    output += `Emails: ${intel.emails.length ? intel.emails.slice(0,5).join(', ') + (intel.emails.length > 5 ? '...' : '') : '‚Äî'}\n`;
    output += `Domains: ${intel.domains.length ? intel.domains.slice(0,5).join(', ') + (intel.domains.length > 5 ? '...' : '') : '‚Äî'}\n`;
    output += `IPs: ${intel.ips.length ? intel.ips.slice(0,5).join(', ') + (intel.ips.length > 5 ? '...' : '') : '‚Äî'}\n`;
    output += `URLs: ${intel.urls.length ? intel.urls.length + ' found' : '‚Äî'}\n`;
    output += `Crypto Addresses: ${intel.cryptoAddresses.length ? intel.cryptoAddresses.join(', ') : '‚Äî'}\n`;
    output += `Hashes: ${intel.hashes.length ? intel.hashes.length + ' found' : '‚Äî'}\n`;
    output += `CVEs: ${intel.cves.length ? intel.cves.join(', ') : '‚Äî'}\n`;
    output += `Phone Numbers: ${intel.phones.length ? intel.phones.slice(0,3).join(', ') : '‚Äî'}\n`;
    output += `Handles: ${intel.handles.length ? intel.handles.slice(0,5).join(', ') : '‚Äî'}\n`;
    
    if(intel.suspiciousStrings.length > 0){
      output += `\nSuspicious Commands:\n`;
      intel.suspiciousStrings.forEach(str => output += `‚Ä¢ ${str}\n`);
    }
    
    output += `\n=== THREAT ASSESSMENT ===\n`;
    output += `Level: ${threat.level} (Score: ${threat.score})\n`;
    if(threat.indicators.length > 0){
      output += `Indicators:\n`;
      threat.indicators.forEach(ind => output += `‚Ä¢ ${ind}\n`);
    }
    
    output += `\n=== INTELLIGENCE QUERIES ===\n`;
    queries.slice(0,6).forEach(q => output += `‚Ä¢ ${q}\n`);
    
    updateNetworkGraph(intel);
    const textMetaNode = el('#textMeta');
    if(textMetaNode) textMetaNode.textContent = output;
    
    updateGlobalStats();
    setStatus('text analysis');
  });
}

// Social Media Analysis Module
const analyzeSocialBtn = el('#analyzeSocial');
if(analyzeSocialBtn) {
  analyzeSocialBtn.addEventListener('click', () => {
    setStatus('analyzing social media');
    const socialTextin = el('#socialTextin');
    const text = socialTextin ? socialTextin.value : '';
    const social = analyzeSocialMedia(text);
    
    globalReport.intelligence.social = social;
    globalReport.stats.socialPosts++;
    
    let output = `=== SOCIAL MEDIA INTELLIGENCE ===\n`;
    output += `Platforms: ${social.platforms.length ? social.platforms.join(', ') : '‚Äî'}\n`;
    output += `Hashtags: ${social.hashtags.length ? social.hashtags.slice(0,8).join(', ') : '‚Äî'}\n`;
    output += `Sentiment: ${social.sentiment}\n`;
    
    if(social.platforms.length > 0){
      output += `\nPlatform-Specific Queries:\n`;
      social.platforms.forEach(platform => {
        output += `‚Ä¢ site:${platform}.com "${text.substring(0,30)}..."\n`;
      });
    }
    
    const socialMetaNode = el('#socialMeta');
    if(socialMetaNode) socialMetaNode.textContent = output;
    
    const socialThreatNode = el('#socialThreatLevel');
    if(socialThreatNode) socialThreatNode.textContent = `sentiment: ${social.sentiment}`;
    
    updateGlobalStats();
    setStatus('social intel');
  });
}

function updateThreatLevel(level) {
  const levels = ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];
  const currentIndex = levels.indexOf(globalReport.stats.maxThreatLevel);
  const newIndex = levels.indexOf(level);
  
  if(newIndex > currentIndex) {
    globalReport.stats.maxThreatLevel = level;
  }
}

function updateThreatDisplay(threat, elementId){
  const threatNode = el(`#${elementId}`);
  if(threatNode) {
    threatNode.textContent = `threat: ${threat.level}`;
    threatNode.style.color = {
      'LOW': '#4ade80',
      'MEDIUM': '#fbbf24', 
      'HIGH': '#f97316',
      'CRITICAL': '#ef4444'
    }[threat.level] || '#9ca3af';
  }
}

// Copy functions
const copyIntelBtn = el('#copyIntel');
if(copyIntelBtn) {
  copyIntelBtn.addEventListener('click', () => {
    const report = JSON.stringify(globalReport, null, 2);
    navigator.clipboard.writeText(report).then(
      () => setStatus('copied report'),
      () => setStatus('copy failed')
    );
  });
}

const copyTextIntelBtn = el('#copyTextIntel');
if(copyTextIntelBtn) {
  copyTextIntelBtn.addEventListener('click', () => {
    const report = JSON.stringify(globalReport, null, 2);
    navigator.clipboard.writeText(report).then(
      () => setStatus('copied report'),
      () => setStatus('copy failed')
    );
  });
}

const copyUrlIntelBtn = el('#copyUrlIntel');
if(copyUrlIntelBtn) {
  copyUrlIntelBtn.addEventListener('click', () => {
    const report = JSON.stringify(globalReport, null, 2);
    navigator.clipboard.writeText(report).then(
      () => setStatus('copied report'),
      () => setStatus('copy failed')
    );
  });
}

const copySocialIntelBtn = el('#copySocialIntel');
if(copySocialIntelBtn) {
  copySocialIntelBtn.addEventListener('click', () => {
    const report = JSON.stringify(globalReport, null, 2);
    navigator.clipboard.writeText(report).then(
      () => setStatus('copied report'),
      () => setStatus('copy failed')
    );
  });
}

const copyIOCsBtn = el('#copyIOCs');
if(copyIOCsBtn) {
  copyIOCsBtn.addEventListener('click', () => {
    const intel = globalReport.intelligence.extracted || {};
    const iocs = [
      ...(intel.ips || []),
      ...(intel.domains || []), 
      ...(intel.hashes || []),
      ...(intel.urls || [])
    ];
    
    const iocText = iocs.join('\n');
    navigator.clipboard.writeText(iocText).then(
      () => setStatus('copied IOCs'),
      () => setStatus('copy failed')
    );
  });
}

const copyHashBtn = el('#copyHash');
if(copyHashBtn) {
  copyHashBtn.addEventListener('click', () => {
    const hash = hashNode ? hashNode.textContent : '';
    if(!hash || hash === '‚Äî') return alert('No hash to copy');
    navigator.clipboard.writeText(hash).then(
      () => setStatus('copied hash'),
      () => setStatus('copy failed')
    );
  });
}

const copyNetworkDataBtn = el('#copyNetworkData');
if(copyNetworkDataBtn) {
  copyNetworkDataBtn.addEventListener('click', () => {
    const networkData = {
      entities: globalReport.intelligence,
      relationships: 'Generated from analysis data',
      timestamp: Date.now()
    };
    const networkJson = JSON.stringify(networkData, null, 2);
    navigator.clipboard.writeText(networkJson).then(
      () => setStatus('copied network data'),
      () => setStatus('copy failed')
    );
  });
}

// Reports Module Functions
function updateReportsPage() {
  const reportSummary = el('#reportSummary');
  if(!reportSummary) return;
  
  let summary = `=== OPERATION INTELLIGENCE SUMMARY ===\n`;
  summary += `Timestamp: ${new Date(globalReport.timestamp).toISOString()}\n`;
  summary += `Duration: ${Math.round((Date.now() - globalReport.timestamp) / 1000)}s\n\n`;
  
  if(globalReport.sources.length === 0) {
    summary += `No analysis data available.\nRun analysis in other modules to generate reports.`;
  } else {
    summary += `=== SOURCES ANALYZED ===\n`;
    globalReport.sources.forEach((source, i) => {
      summary += `${i+1}. ${source.type.toUpperCase()}: `;
      if(source.name) summary += source.name;
      else if(source.value) summary += source.value.substring(0, 50) + '...';
      else if(source.length) summary += `${source.length} characters`;
      summary += `\n`;
    });
    
    summary += `\n=== INTELLIGENCE SUMMARY ===\n`;
    Object.entries(globalReport.intelligence).forEach(([key, data]) => {
      summary += `${key.toUpperCase()}:\n`;
      if(data.ips) summary += `  IPs: ${data.ips.length}\n`;
      if(data.domains) summary += `  Domains: ${data.domains.length}\n`;
      if(data.emails) summary += `  Emails: ${data.emails.length}\n`;
      if(data.hashes) summary += `  Hashes: ${data.hashes.length}\n`;
      if(data.cryptoAddresses) summary += `  Crypto: ${data.cryptoAddresses.length}\n`;
      if(data.platforms) summary += `  Platforms: ${data.platforms.join(', ')}\n`;
      if(data.sentiment) summary += `  Sentiment: ${data.sentiment}\n`;
    });
    
    if(globalReport.threats.indicators) {
      summary += `\n=== THREAT INDICATORS ===\n`;
      globalReport.threats.indicators.forEach(indicator => {
        summary += `‚Ä¢ ${indicator}\n`;
      });
    }
  }
  
  reportSummary.textContent = summary;
}

// Export functionality
const exportBtn = el('#exportBtn');
if(exportBtn) {
  exportBtn.addEventListener('click', () => {
    const timestamp = new Date().toISOString().slice(0,19).replace(/[:.]/g, '-');
    const filename = `redfront-intel-${timestamp}.json`;
    
    const blob = new Blob([JSON.stringify(globalReport, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
    setStatus('exported JSON');
  });
}

const exportCSVBtn = el('#exportCSV');
if(exportCSVBtn) {
  exportCSVBtn.addEventListener('click', () => {
    let csv = 'Type,Value,Source,Timestamp\n';
    
    Object.entries(globalReport.intelligence).forEach(([source, data]) => {
      if(data.ips) data.ips.forEach(ip => csv += `IP,${ip},${source},${Date.now()}\n`);
      if(data.domains) data.domains.forEach(domain => csv += `Domain,${domain},${source},${Date.now()}\n`);
      if(data.emails) data.emails.forEach(email => csv += `Email,${email},${source},${Date.now()}\n`);
      if(data.hashes) data.hashes.forEach(hash => csv += `Hash,${hash},${source},${Date.now()}\n`);
    });
    
    const timestamp = new Date().toISOString().slice(0,19).replace(/[:.]/g, '-');
    const filename = `redfront-iocs-${timestamp}.csv`;
    
    const blob = new Blob([csv], {type: 'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
    setStatus('exported CSV');
  });
}

const exportTXTBtn = el('#exportTXT');
if(exportTXTBtn) {
  exportTXTBtn.addEventListener('click', () => {
    let txt = 'REDFRONT OSINT WORKBENCH - INTELLIGENCE REPORT\n';
    txt += '=' .repeat(50) + '\n\n';
    txt += `Generated: ${new Date().toISOString()}\n\n`;
    
    const intel = globalReport.intelligence.extracted || {};
    txt += 'INDICATORS OF COMPROMISE (IOCs):\n';
    txt += '-'.repeat(30) + '\n';
    
    if(intel.ips?.length) {
      txt += `\nIP Addresses (${intel.ips.length}):\n`;
      intel.ips.forEach(ip => txt += `${ip}\n`);
    }
    
    if(intel.domains?.length) {
      txt += `\nDomains (${intel.domains.length}):\n`;
      intel.domains.forEach(domain => txt += `${domain}\n`);
    }
    
    if(intel.hashes?.length) {
      txt += `\nFile Hashes (${intel.hashes.length}):\n`;
      intel.hashes.forEach(hash => txt += `${hash}\n`);
    }
    
    const timestamp = new Date().toISOString().slice(0,19).replace(/[:.]/g, '-');
    const filename = `redfront-report-${timestamp}.txt`;
    
    const blob = new Blob([txt], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
    setStatus('exported TXT');
  });
}

// Initialize
setStatus('command center');
</script>
</body>
</html>
