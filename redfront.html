<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Redfront OSINT Brief — Single File</title>
<style>
:root{
  --bg:#080808; --panel:#0f0f0f; --muted:#bfbfbf; --red:#c21a1a; --accent:#bf7b2d;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--muted);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
.container{display:grid;grid-template-rows:auto 1fr;gap:10px;padding:12px;min-height:100vh}
.header{display:flex;gap:12px;align-items:center}
.logo{width:64px;height:40px;flex:0 0 auto}
.h1{font-weight:800;color:var(--red);letter-spacing:.06em}
.top-controls{margin-left:auto;display:flex;gap:8px;align-items:center}
.button{background:var(--red);border:0;padding:8px 10px;border-radius:6px;color:#fff;font-weight:700;cursor:pointer}
.layout{display:grid;grid-template-columns:360px 1fr;gap:12px;align-items:start}
.panel{background:linear-gradient(180deg,#0b0b0b,#060606);border-radius:8px;padding:12px;box-shadow:0 6px 20px rgba(0,0,0,.6)}
.small{font-size:13px;color:#b7b7b7}
.filedrop{border:1px dashed rgba(200,30,30,.18);padding:12px;border-radius:6px;text-align:center;color:var(--muted);cursor:pointer}
.console{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;font-size:13px;line-height:1.4;color:#e9e9e9;background:#090909;padding:8px;border-radius:6px;max-height:360px;overflow:auto}
.row{display:flex;gap:8px;align-items:center}
.field{display:flex;flex-direction:column;gap:6px}
.kv{display:flex;justify-content:space-between;border-bottom:1px dashed rgba(255,255,255,.03);padding:6px 0}
.mapwrap{height:240px;background:linear-gradient(180deg,#0a0505,#070707);border-radius:6px;display:flex;align-items:center;justify-content:center;position:relative}
.map{width:100%;height:100%}
.badge{background:#0b0b0b;padding:6px 8px;border-radius:6px;font-size:12px;color:var(--muted)}
.controls{display:flex;gap:8px;flex-wrap:wrap}
.smallmuted{font-size:12px;color:#9a9a9a}
.footer{display:flex;justify-content:space-between;align-items:center;margin-top:6px;color:#888;font-size:12px}
.copy{background:transparent;border:1px solid rgba(255,255,255,.06);padding:6px 8px;border-radius:6px;color:var(--muted);cursor:pointer}
.hint{font-size:12px;color:#777}
@media(max-width:880px){.layout{grid-template-columns:1fr;}}
/* subtle gritty overlay */
.grit{position:absolute;inset:0;pointer-events:none;opacity:.06;mix-blend-mode:overlay}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <svg class="logo" viewBox="0 0 72 48" xmlns="http://www.w3.org/2000/svg" aria-hidden>
      <rect width="72" height="48" fill="#050505"/>
      <g transform="translate(6,6)" stroke="#c21a1a" stroke-width="6" stroke-linecap="square" fill="none">
        <path d="M0 0h24v36"/>
        <path d="M30 0v36H6"/>
      </g>
    </svg>
    <div>
      <div class="h1">Redfront OSINT Brief</div>
      <div class="small">Single-file tactical OSINT — client-side metadata & indicators</div>
    </div>
    <div class="top-controls">
      <div class="badge smallmuted" id="status">idle</div>
      <button class="button" id="exportBtn" title="Download JSON report">EXPORT</button>
    </div>
  </div>

  <div class="layout">
    <div class="panel">
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:10px">
        <div style="flex:1">
          <div class="small">Input (image or text)</div>
          <div id="filedrop" class="filedrop" tabindex="0">Drag & drop JPG, or click to select. Or paste text into the box below.</div>
        </div>
        <div style="width:120px">
          <div class="small">Hash</div>
          <div class="kv">
            <div style="color:#aaa;font-size:13px">SHA-256</div>
            <div id="hash" class="smallmuted">—</div>
          </div>
          <div style="height:8px"></div>
          <button id="copyHash" class="copy" title="Copy hash">Copy</button>
        </div>
      </div>

      <div style="margin-top:10px">
        <div class="small">Paste text / notes</div>
        <textarea id="textin" placeholder="Paste a tweet, HTML snippet, or notes here..." style="width:100%;height:120px;margin-top:6px;padding:8px;border-radius:6px;background:#0b0b0b;border:1px solid rgba(255,255,255,.04);color:#eee"></textarea>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
          <button id="analyzeText" class="button">ANALYZE TEXT</button>
          <div class="hint">Extracts emails, domains, IPs, phone numbers, handles</div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div style="display:flex;gap:8px;align-items:start;justify-content:space-between">
        <div style="flex:1">
          <div class="small">Parsed metadata</div>
          <div id="meta" class="console" aria-live="polite">No input yet.</div>
        </div>
        <div style="width:320px">
          <div class="small">Map / preview</div>
          <div class="mapwrap" id="mapwrap">
            <!-- simple equirect map -->
            <svg id="map" class="map" viewBox="0 0 360 180" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
              <defs>
                <filter id="n">
                  <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="1" stitchTiles="stitch"/>
                  <feColorMatrix type="saturate" values="0"/>
                  <feComponentTransfer><feFuncA type="table" tableValues="0 0.6"/></feComponentTransfer>
                </filter>
              </defs>
              <rect width="360" height="180" fill="#0b0b0b"/>
              <g id="markerLayer"></g>
              <text x="50%" y="50%" fill="#6b6b6b" font-size="12" text-anchor="middle" dy=".35em">No geotagged image</text>
            </svg>
            <svg class="grit" viewBox="0 0 360 180" xmlns="http://www.w3.org/2000/svg"><rect width="360" height="180" filter="url(#n)" fill="#000"/></svg>
          </div>

          <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <button id="copySearch" class="copy" title="Copy search queries">COPY SEARCH</button>
            <button id="downloadBtn" class="copy" title="Download artifact">DOWNLOAD FILE</button>
            <div style="flex:1"></div>
            <div class="smallmuted" id="coords">lat: — lon: —</div>
          </div>
        </div>
      </div>

      <div style="margin-top:10px" class="footer">
        <div class="smallmuted">Everything processed locally. No network calls.</div>
        <div class="smallmuted">Tip: export the JSON report and stash it in your case folder.</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ========= Utilities ========= */
const el = sel => document.querySelector(sel);
const status = el('#status');
function setStatus(s){ status.textContent = s; }

function ab2hex(buf){
  const a = [...new Uint8Array(buf)];
  return a.map(b=>b.toString(16).padStart(2,'0')).join('');
}

/* ========= SHA-256 (file fingerprint) ========= */
async function hashFile(blob){
  const buf = await blob.arrayBuffer();
  const h = await crypto.subtle.digest('SHA-256', buf);
  return ab2hex(h);
}

/* ========= EXIF parser (minimal: scans APP1 for "Exif" and reads TIFF tags) ========= */
/* Reads JPEG APP1 Exif payload and returns selected tags incl GPS IFD */
function parseEXIFFromJPEG(buffer){
  const dv = new DataView(buffer);
  let offset = 2; // skip SOI
  const len = dv.byteLength;
  while(offset < len){
    // basic bounds checks before reads
    if(offset + 4 > len) break;
    if(dv.getUint8(offset) !== 0xFF) break;
    const marker = dv.getUint8(offset+1);
    const size = dv.getUint16(offset+2);
    if(marker === 0xE1){ // APP1
      // check for "Exif\0\0"
      const start = offset + 4;
      // ensure there's room for the Exif header + TIFF header
      if(start + 6 <= len && getString(buffer, start, 4) === 'Exif'){
        const tiffOffset = start + 6; // TIFF header (relative inside this buffer)
        // pass an ArrayBuffer that starts at the TIFF header
        return readTIFF(buffer.slice(tiffOffset));
      }
    }
    offset += 2 + size;
  }
  return null;
}

function getString(buf, start, len){
  return String.fromCharCode(...new Uint8Array(buf.slice(start, start+len)));
}

function readTIFF(buf){
  const dv = new DataView(buf);
  // minimal check: need at least 8 bytes for header + first IFD offset
  if(dv.byteLength < 8) return null;
  const little = dv.getUint16(0, false) === 0x4949; // II
  const endian = little;
  const getUint16 = (off)=>dv.getUint16(off, endian);
  const getUint32 = (off)=>dv.getUint32(off, endian);
  const getInt32 = (off)=>dv.getInt32(off, endian);

  const firstIfdOffset = getUint32(4);
  const tags = {};
  function readIFD(ifdOffset){
    // bounds: ensure we can read the entry count
    if(ifdOffset + 2 > dv.byteLength) return 0;
    const n = getUint16(ifdOffset);
    const base = ifdOffset + 2;
    for(let i=0;i<n;i++){
      const o = base + i*12;
      // ensure the full 12-byte directory entry fits
      if(o + 12 > dv.byteLength) break;
      const tag = getUint16(o);
      const type = getUint16(o+2);
      const count = getUint32(o+4);
      const valueOffset = getUint32(o+8);
      const val = readTagValue(type, count, valueOffset, o);
      tags[tag] = val;
    }
    const nextPtrOff = base + n*12;
    if(nextPtrOff + 4 > dv.byteLength) return 0;
    const next = getUint32(nextPtrOff);
    return next;
  }
  function readTagValue(type,count,vo){
    // types size map
    const typeSize = {1:1,2:1,3:2,4:4,5:8};
    const entryInline = (count * (typeSize[type]||1)) <= 4;
    // if value is stored inline in the directory entry, it's at offset (entryOffset + 8)
    // note: we receive the entryOffset as a 4th arg when called from readIFD
    const entryOffset = arguments[3] || 0;

    if(type === 2){ // ASCII
      if(entryInline){
        const off = entryOffset + 8;
        if(off + count > dv.byteLength) return null;
        return getString(buf, off, count-1);
      } else {
        if(vo + count > dv.byteLength) return null;
        return getString(buf, vo, count-1);
      }
    }
    if(type === 3){ // SHORT
      if(count === 1){
        if(entryInline){
          const off = entryOffset + 8;
          if(off + 2 > dv.byteLength) return null;
          return dv.getUint16(off, endian);
        } else {
          if(vo + 2 > dv.byteLength) return null;
          return dv.getUint16(vo, endian);
        }
      }
      // multiple shorts -> read from offset
      if(!entryInline){
        if(vo + count*2 > dv.byteLength) return null;
        const out = [];
        for(let i=0;i<count;i++) out.push(dv.getUint16(vo + i*2, endian));
        return out;
      }
    }
    if(type === 4){ // LONG
      if(count === 1){
        if(entryInline){
          const off = entryOffset + 8;
          if(off + 4 > dv.byteLength) return null;
          return dv.getUint32(off, endian);
        } else {
          if(vo + 4 > dv.byteLength) return null;
          return dv.getUint32(vo, endian);
        }
      }
      // multiple longs
      if(!entryInline){
        if(vo + count*4 > dv.byteLength) return null;
        const out = [];
        for(let i=0;i<count;i++) out.push(dv.getUint32(vo + i*4, endian));
        return out;
      }
    }
    if(type === 5){ // RATIONAL (numerator/denominator pairs)
      // vo is offset to numerator/denominator
      if(vo + count*8 > dv.byteLength) return null;
      // if count==1, return a single rational; otherwise return array
      if(count === 1){
        const num = dv.getUint32(vo, endian);
        const den = dv.getUint32(vo+4, endian);
        return den === 0 ? null : (num/den);
      }
      const arr = [];
      for(let i=0;i<count;i++){
        const off = vo + i*8;
        const num = dv.getUint32(off, endian);
        const den = dv.getUint32(off+4, endian);
        arr.push(den === 0 ? null : (num/den));
      }
      return arr;
    }
    // fallback: return raw numeric offset or null if out of bounds
    return (vo + 0 <= dv.byteLength) ? vo : null;
  }

  // helper to read rational arrays for GPS coords
  function readRationals(offset,count){
    const out = [];
    // bounds check
    if(offset + count*8 > dv.byteLength) return out;
    for(let i=0;i<count;i++){
      const num = dv.getUint32(offset + i*8, endian);
      const den = dv.getUint32(offset + i*8 + 4, endian);
      out.push(den === 0 ? null : num/den);
    }
    return out;
  }

  // read 0th IFD tags
  const ifd0 = firstIfdOffset;
  readIFD(ifd0);

  // look for tag 0x8825 GPSInfo IFD pointer
  const GPS_TAG = 0x8825;
  const gps = {};
  if(tags[GPS_TAG]){
    const gpsOffset = tags[GPS_TAG];
    // read GPS IFD entries
    const n = dv.getUint16(gpsOffset, endian);
    for(let i=0;i<n;i++){
      const o = gpsOffset + 2 + i*12;
      const tag = dv.getUint16(o, endian);
      const type = dv.getUint16(o+2, endian);
      const count = dv.getUint32(o+4, endian);
      const valueOffset = dv.getUint32(o+8, endian);
      // GPS tags of interest:
      // 0x0001: GPSLatitudeRef (ASCII)
      // 0x0002: GPSLatitude (3 rationals)
      // 0x0003: GPSLongitudeRef
      // 0x0004: GPSLongitude
      // 0x0006: GPSAltitude (rational)
      if(tag===0x0001 || tag===0x0003){ // ASCII
        gps[tag] = getString(buf, valueOffset, count-1);
      } else if(tag===0x0002 || tag===0x0004){
        // read 3 rationals
        gps[tag] = readRationals(valueOffset, count);
      } else if(tag===0x0006){
        const num = dv.getUint32(valueOffset, endian);
        const den = dv.getUint32(valueOffset+4, endian);
        gps[tag] = num/den;
      }
    }
  }

  // get some human tags: 0x010F Make, 0x0110 Model, 0x0132 DateTime
  const out = {
    make: tags[0x010F] || null,
    model: tags[0x0110] || null,
    datetime: tags[0x0132] || null,
    gps: gps && Object.keys(gps).length ? gps : null
  };
  return out;
}

// convert GPS rationals [deg, min, sec] + ref to decimal
function gpsToDecimal(arr, ref){
  if(!arr || arr.length < 3) return null;
  const deg = arr[0];
  const min = arr[1];
  const sec = arr[2];
  let dec = deg + (min/60) + (sec/3600);
  if(ref === 'S' || ref === 'W') dec = -dec;
  return dec;
}

/* ========= Indicator extraction from text ========= */
function extractIndicators(text){
  const out = {emails:[],domains:[],ips:[],phones:[],handles:[]};
  // basic regexes (not perfect but practical)
  const emailRe = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
  const ipRe = /\b(?:\d{1,3}\.){3}\d{1,3}\b/g;
  const domainRe = /\b(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z]{2,}\b/gi;
  const phoneRe = /(?:\+?\d{1,3}[-.\s]?)?(?:\(?\d{2,4}\)?[-.\s]?)?\d{3,4}[-.\s]?\d{3,4}/g;
  const handleRe = /@([A-Za-z0-9_]{3,30})/g;

  const addUnique = (arr, v)=>{ if(!v) return; if(!arr.includes(v)) arr.push(v) };

  let m;
  while(m = emailRe.exec(text)) addUnique(out.emails, m[0]);
  while(m = ipRe.exec(text)) addUnique(out.ips, m[0]);
  while(m = handleRe.exec(text)) addUnique(out.handles, '@'+m[1]);
  while(m = domainRe.exec(text)) addUnique(out.domains, m[0]);
  while(m = phoneRe.exec(text)) {
    const s = m[0].replace(/\s+/g,'');
    if(s.length>=7 && s.length<=15) addUnique(out.phones, m[0]);
  }
  // remove emails from domains list
  out.domains = out.domains.filter(d=> !out.emails.some(e=> e.includes(d)));
  return out;
}

/* ========= UI interactions ========= */
const filedrop = el('#filedrop');
const textin = el('#textin');
const metaNode = el('#meta');
const hashNode = el('#hash');
const coordsNode = el('#coords');
const markerLayer = el('#markerLayer');
let currentReport = {sources:[],indicators:{},meta:{},hashes:{}}; // accumulates

filedrop.addEventListener('click', ()=> {
  const inp = document.createElement('input');
  inp.type='file'; inp.accept='image/jpeg,image/jpg';
  inp.onchange = ()=> handleFile(inp.files[0]);
  inp.click();
});

filedrop.addEventListener('dragover', e=>{ e.preventDefault(); filedrop.style.background='rgba(255,0,0,.03)'; });
filedrop.addEventListener('dragleave', e=>{ filedrop.style.background=''; });
filedrop.addEventListener('drop', e=>{ e.preventDefault(); filedrop.style.background=''; const f = e.dataTransfer.files && e.dataTransfer.files[0]; if(f) handleFile(f); });

async function handleFile(file){
  setStatus('processing file');
  currentReport.sources.push({filename:file.name,size:file.size,type:file.type,ts:Date.now()});
  // compute hash
  try{
    const h = await hashFile(file);
    hashNode.textContent = h;
    currentReport.hashes[file.name] = h;
  }catch(e){ hashNode.textContent = 'err'; }
  // read header bytes for EXIF
  const header = await file.slice(0, 128000).arrayBuffer(); // first 128KB should contain APP1
  const exif = parseEXIFFromJPEG(header);
  let outText = '';
  if(exif){
    outText += `Make: ${exif.make||'—'}\n`;
    outText += `Model: ${exif.model||'—'}\n`;
    outText += `DateTime: ${exif.datetime||'—'}\n`;
    if(exif.gps){
      const lat = gpsToDecimal(exif.gps[0x0002], exif.gps[0x0001]);
      const lon = gpsToDecimal(exif.gps[0x0004], exif.gps[0x0003]);
      outText += `GPS lat: ${lat!==null?lat.toFixed(6):'—'} lon: ${lon!==null?lon.toFixed(6):'—'}\n`;
      currentReport.meta.gps = {lat,lon};
      updateMap(lat,lon);
      coordsNode.textContent = `lat: ${lat!==null?lat.toFixed(6):'—'} lon: ${lon!==null?lon.toFixed(6):'—'}`;
    } else {
      outText += 'GPS: —\n';
      clearMap();
      coordsNode.textContent = 'lat: — lon: —';
    }
    currentReport.meta.datetime = exif.datetime || null;
    currentReport.meta.make = exif.make || null;
    currentReport.meta.model = exif.model || null;
  } else {
    outText = 'No EXIF found (or not a JPG with EXIF).';
    clearMap();
  }
  metaNode.textContent = outText;
  setStatus('idle');
}

/* ========= Map helper (simple equirect projection) ========= */
function updateMap(lat,lon){
  markerLayer.innerHTML = '';
  if(lat===null || lon===null || isNaN(lat) || isNaN(lon)) return;
  // map viewBox 0..360 (lon -180..180 => 0..360), 0..180 (lat 90..-90)
  const x = (lon + 180) * (360/360);
  const y = (90 - lat) * (180/180);
  // create marker
  const svgNS = 'http://www.w3.org/2000/svg';
  const g = document.createElementNS(svgNS,'g');
  const circ = document.createElementNS(svgNS,'circle');
  circ.setAttribute('cx', x);
  circ.setAttribute('cy', y);
  circ.setAttribute('r', '3');
  circ.setAttribute('fill', '#c21a1a');
  circ.setAttribute('stroke', '#fff');
  circ.setAttribute('stroke-width', '0.6');
  g.appendChild(circ);
  const t = document.createElementNS(svgNS,'text');
  t.setAttribute('x', x+6);
  t.setAttribute('y', y+4);
  t.setAttribute('fill','#ddd');
  t.setAttribute('font-size','9');
  t.textContent = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
  g.appendChild(t);
  markerLayer.appendChild(g);
}

function clearMap(){ markerLayer.innerHTML = ''; }

/* ========= Text analysis & search gen ========= */
el('#analyzeText').addEventListener('click', ()=> {
  setStatus('analyzing text');
  const txt = textin.value || '';
  const inds = extractIndicators(txt);
  currentReport.indicators = inds;
  // build output
  let out = '';
  out += '=== Indicators ===\n';
  out += 'Emails: ' + (inds.emails.length?inds.emails.join(', '):'—') + '\n';
  out += 'Domains: ' + (inds.domains.length?inds.domains.join(', '):'—') + '\n';
  out += 'IPs: ' + (inds.ips.length?inds.ips.join(', '):'—') + '\n';
  out += 'Phones: ' + (inds.phones.length?inds.phones.join(', '):'—') + '\n';
  out += 'Handles: ' + (inds.handles.length?inds.handles.join(', '):'—') + '\n\n';
  out += '=== Search queries ===\n';
  const queries = buildSearchQueries(inds);
  out += queries.map(q=>'• '+q).join('\n');
  metaNode.textContent = out;
  setStatus('idle');
});

function buildSearchQueries(ind){
  const q = [];
  (ind.emails||[]).forEach(e => q.push(`"${e}"`));
  (ind.domains||[]).forEach(d => q.push(`site:${d} OR "${d}"`));
  (ind.ips||[]).forEach(i => q.push(`"${i}"`));
  (ind.handles||[]).forEach(h => q.push(`"${h}" OR "${h.replace('@','')}"`));
  if(!q.length) q.push('site:twitter.com "username"');
  return q.slice(0,8);
}

el('#copySearch').addEventListener('click', ()=> {
  const txt = metaNode.textContent || '';
  navigator.clipboard.writeText(txt).then(()=> alert('Copied search output to clipboard'), ()=> alert('Copy failed'));
});

/* ========= export / download ========= */
el('#exportBtn').addEventListener('click', ()=> {
  downloadReport();
});

function downloadReport(){
  const blob = new Blob([JSON.stringify(currentReport,null,2)],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'redfront_report.json';
  document.body.appendChild(a); a.click(); a.remove();
  setTimeout(()=>URL.revokeObjectURL(url),2000);
}

/* allow downloading the current selected file blob (if any) - placeholder */
el('#downloadBtn').addEventListener('click', ()=> {
  alert('Use EXPORT to download JSON report with extracted info (file data not included).');
});

/* copy hash */
el('#copyHash').addEventListener('click', ()=> {
  const h = hashNode.textContent || '';
  if(!h || h==='—') return alert('No hash to copy');
  navigator.clipboard.writeText(h).then(()=> setStatus('copied hash'), ()=> setStatus('copy failed'));
});

/* initializations */
setStatus('idle');
</script>
</body>
</html>
