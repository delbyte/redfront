<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Redfront OSINT Workbench — All-in-One Intelligence Analysis</title>
<style>
:root{
  --bg:#080808; --panel:#0f0f0f; --muted:#bfbfbf; --red:#c21a1a; --accent:#bf7b2d;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:var(--muted);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
.container{display:grid;grid-template-rows:auto 1fr;gap:10px;padding:12px;min-height:100vh}
.header{display:flex;gap:12px;align-items:center}
.logo{width:64px;height:40px;flex:0 0 auto}
.h1{font-weight:800;color:var(--red);letter-spacing:.06em}
.top-controls{margin-left:auto;display:flex;gap:8px;align-items:center}
.button{background:var(--red);border:0;padding:8px 10px;border-radius:6px;color:#fff;font-weight:700;cursor:pointer}
.layout{display:grid;grid-template-columns:360px 1fr;gap:12px;align-items:start}
.panel{background:linear-gradient(180deg,#0b0b0b,#060606);border-radius:8px;padding:12px;box-shadow:0 6px 20px rgba(0,0,0,.6)}
.small{font-size:13px;color:#b7b7b7}
.filedrop{border:1px dashed rgba(200,30,30,.18);padding:12px;border-radius:6px;text-align:center;color:var(--muted);cursor:pointer}
.console{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;font-size:13px;line-height:1.4;color:#e9e9e9;background:#090909;padding:8px;border-radius:6px;max-height:360px;overflow:auto}
.row{display:flex;gap:8px;align-items:center}
.field{display:flex;flex-direction:column;gap:6px}
.kv{display:flex;justify-content:space-between;border-bottom:1px dashed rgba(255,255,255,.03);padding:6px 0}
.mapwrap{height:240px;background:linear-gradient(180deg,#0a0505,#070707);border-radius:6px;display:flex;align-items:center;justify-content:center;position:relative}
.map{width:100%;height:100%}
.badge{background:#0b0b0b;padding:6px 8px;border-radius:6px;font-size:12px;color:var(--muted)}
.controls{display:flex;gap:8px;flex-wrap:wrap}
.smallmuted{font-size:12px;color:#9a9a9a}
.footer{display:flex;justify-content:space-between;align-items:center;margin-top:6px;color:#888;font-size:12px}
.copy{background:transparent;border:1px solid rgba(255,255,255,.06);padding:6px 8px;border-radius:6px;color:var(--muted);cursor:pointer}
.hint{font-size:12px;color:#777}
@media(max-width:880px){.layout{grid-template-columns:1fr;}}
/* subtle gritty overlay */
.grit{position:absolute;inset:0;pointer-events:none;opacity:.06;mix-blend-mode:overlay}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <svg class="logo" viewBox="0 0 72 48" xmlns="http://www.w3.org/2000/svg" aria-hidden>
      <rect width="72" height="48" fill="#050505"/>
      <g transform="translate(6,6)" stroke="#c21a1a" stroke-width="6" stroke-linecap="square" fill="none">
        <path d="M0 0h24v36"/>
        <path d="M30 0v36H6"/>
      </g>
    </svg>
    <div>
      <div class="h1">Redfront OSINT Workbench</div>
      <div class="small">All-in-one tactical OSINT — multi-format analysis & intelligence extraction</div>
    </div>
    <div class="top-controls">
      <div class="badge smallmuted" id="status">idle</div>
      <button class="button" id="exportBtn" title="Download JSON report">EXPORT</button>
    </div>
  </div>

  <div class="layout">
    <div class="panel">
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:10px">
        <div style="flex:1">
          <div class="small">Input (files, URLs, or text)</div>
          <div id="filedrop" class="filedrop" tabindex="0">Drag & drop files, or click to select. Supports images, documents, archives, executables.</div>
        </div>
        <div style="width:120px">
          <div class="small">File Hash</div>
          <div class="kv">
            <div style="color:#aaa;font-size:13px">SHA-256</div>
            <div id="hash" class="smallmuted">—</div>
          </div>
          <div style="height:8px"></div>
          <button id="copyHash" class="copy" title="Copy hash">Copy</button>
        </div>
      </div>

      <div style="margin-top:10px">
        <div class="small">URL / Domain Analysis</div>
        <input id="urlin" placeholder="https://example.com or paste URLs here..." style="width:100%;margin-top:6px;padding:8px;border-radius:6px;background:#0b0b0b;border:1px solid rgba(255,255,255,.04);color:#eee"/>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
          <button id="analyzeUrl" class="button">ANALYZE URL</button>
          <div class="hint">Extracts domains, subdomains, parameters, potential IOCs</div>
        </div>
      </div>

      <div style="margin-top:10px">
        <div class="small">Text / Social Media Intelligence</div>
        <textarea id="textin" placeholder="Paste tweets, posts, messages, source code, logs, or any text content..." style="width:100%;height:120px;margin-top:6px;padding:8px;border-radius:6px;background:#0b0b0b;border:1px solid rgba(255,255,255,.04);color:#eee"></textarea>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center;flex-wrap:wrap">
          <button id="analyzeText" class="button">EXTRACT INTEL</button>
          <button id="analyzeSocial" class="button">SOCIAL ANALYSIS</button>
          <div class="hint">Extracts emails, domains, IPs, phone numbers, handles, crypto addresses, timestamps</div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div style="display:flex;gap:8px;align-items:start;justify-content:space-between">
        <div style="flex:1">
          <div class="small">Analysis Results</div>
          <div id="meta" class="console" aria-live="polite">No input yet. Drop files, paste URLs, or analyze text to begin.</div>
        </div>
        <div style="width:320px">
          <div class="small">Network Graph / Visualization</div>
          <div class="mapwrap" id="mapwrap">
            <svg id="map" class="map" viewBox="0 0 360 180" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
              <defs>
                <filter id="n">
                  <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="1" stitchTiles="stitch"/>
                  <feColorMatrix type="saturate" values="0"/>
                  <feComponentTransfer><feFuncA type="table" tableValues="0 0.6"/></feComponentTransfer>
                </filter>
              </defs>
              <rect width="360" height="180" fill="#0b0b0b"/>
              <g id="networkLayer"></g>
              <text x="50%" y="50%" fill="#6b6b6b" font-size="12" text-anchor="middle" dy=".35em">Entity relationships will appear here</text>
            </svg>
            <svg class="grit" viewBox="0 0 360 180" xmlns="http://www.w3.org/2000/svg"><rect width="360" height="180" filter="url(#n)" fill="#000"/></svg>
          </div>

          <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <button id="copyIntel" class="copy" title="Copy intelligence report">COPY INTEL</button>
            <button id="copyIOCs" class="copy" title="Copy IOCs for SIEM">COPY IOCS</button>
            <div style="flex:1"></div>
            <div class="smallmuted" id="threatLevel">threat: — </div>
          </div>
        </div>
      </div>

      <div style="margin-top:10px" class="footer">
        <div class="smallmuted">Everything processed locally. No network calls. Privacy-focused OSINT.</div>
        <div class="smallmuted">Tip: export intelligence reports in multiple formats for your investigation.</div>
      </div>
    </div>
  </div>
</div>

<script>
/* ========= REDFRONT OSINT WORKBENCH ========= */
/* Advanced client-side intelligence analysis toolkit */

const el = sel => document.querySelector(sel);
const status = el('#status');
function setStatus(s){ status.textContent = s; }

function ab2hex(buf){
  const a = [...new Uint8Array(buf)];
  return a.map(b=>b.toString(16).padStart(2,'0')).join('');
}

/* ========= File Analysis & Hashing ========= */
async function hashFile(blob){
  const buf = await blob.arrayBuffer();
  const h = await crypto.subtle.digest('SHA-256', buf);
  return ab2hex(h);
}

async function analyzeFileHeader(blob){
  const header = blob.slice(0, 512);
  const buf = await header.arrayBuffer();
  const bytes = new Uint8Array(buf);
  
  // File signature detection
  const signatures = {
    'PNG': [0x89, 0x50, 0x4E, 0x47],
    'JPEG': [0xFF, 0xD8, 0xFF],
    'PDF': [0x25, 0x50, 0x44, 0x46],
    'ZIP': [0x50, 0x4B, 0x03, 0x04],
    'PE/EXE': [0x4D, 0x5A], // MZ header
    'ELF': [0x7F, 0x45, 0x4C, 0x46],
    'GIF': [0x47, 0x49, 0x46, 0x38],
    'WEBP': [0x52, 0x49, 0x46, 0x46], // RIFF
    'MP4': [0x66, 0x74, 0x79, 0x70], // ftyp (offset 4)
    'DOCX': [0x50, 0x4B, 0x03, 0x04], // Office Open XML
  };
  
  for(const [type, sig] of Object.entries(signatures)){
    if(sig.every((byte, i) => bytes[i] === byte || (type === 'MP4' && i < 4 && bytes[i+4] === byte))){
      return { type, suspicious: ['PE/EXE', 'ELF'].includes(type) };
    }
  }
  
  return { type: 'Unknown', suspicious: false };
}

/* ========= Advanced Indicator Extraction ========= */
function extractIntelligence(text){
  const intel = {
    emails: [], domains: [], ips: [], phones: [], handles: [], 
    cryptoAddresses: [], urls: [], hashes: [], cves: [], 
    coordinates: [], timestamps: [], userAgents: [],
    suspiciousStrings: [], base64Strings: []
  };
  
  // Enhanced regex patterns for comprehensive extraction
  const patterns = {
    email: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g,
    ip: /\b(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\b/g,
    domain: /\b(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z]{2,}\b/gi,
    phone: /(?:\+?\d{1,3}[-.\s]?)?(?:\(?\d{2,4}\)?[-.\s]?)?\d{3,4}[-.\s]?\d{3,4}/g,
    handle: /@([A-Za-z0-9_]{3,30})/g,
    url: /https?:\/\/[^\s<>"']+/gi,
    btcAddress: /\b[13][a-km-zA-HJ-NP-Z1-9]{25,34}\b/g,
    ethAddress: /\b0x[a-fA-F0-9]{40}\b/g,
    md5: /\b[a-f0-9]{32}\b/gi,
    sha1: /\b[a-f0-9]{40}\b/gi,
    sha256: /\b[a-f0-9]{64}\b/gi,
    cve: /CVE-\d{4}-\d{4,}/gi,
    coordinates: /[-+]?(?:[1-8]?\d(?:\.\d+)?|90(?:\.0+)?),\s*[-+]?(?:180(?:\.0+)?|(?:(?:1[0-7]\d)|(?:[1-9]?\d))(?:\.\d+)?)/g,
    timestamp: /\d{4}-\d{2}-\d{2}[T\s]\d{2}:\d{2}:\d{2}(?:\.\d{3})?(?:Z|[+-]\d{2}:?\d{2})?/g,
    userAgent: /Mozilla\/[\d.]+\s*\([^)]+\)[^;]*/gi,
    base64: /(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=|[A-Za-z0-9+\/]{4})/g
  };
  
  const addUnique = (arr, val) => { if(val && !arr.includes(val)) arr.push(val); };
  
  // Extract all patterns
  let match;
  for(const [key, regex] of Object.entries(patterns)){
    while((match = regex.exec(text)) !== null){
      const value = match[0];
      
      if(key === 'handle') addUnique(intel.handles, '@' + match[1]);
      else if(key === 'btcAddress' || key === 'ethAddress') addUnique(intel.cryptoAddresses, value);
      else if(key === 'md5' || key === 'sha1' || key === 'sha256') addUnique(intel.hashes, value);
      else if(key === 'base64' && value.length > 20) addUnique(intel.base64Strings, value);
      else if(intel[key + 's']) addUnique(intel[key + 's'], value);
      else if(intel[key]) addUnique(intel[key], value);
    }
  }
  
  // Filter domains to remove email domains
  intel.domains = intel.domains.filter(d => !intel.emails.some(e => e.includes(d)));
  
  // Detect suspicious strings
  const suspiciousPatterns = [
    /powershell|cmd\.exe|bash|\/bin\/sh/gi,
    /eval\s*\(|exec\s*\(|system\s*\(/gi,
    /base64\s*-d|atob\s*\(/gi,
    /wget|curl|invoke-webrequest/gi
  ];
  
  suspiciousPatterns.forEach(pattern => {
    while((match = pattern.exec(text)) !== null){
      addUnique(intel.suspiciousStrings, match[0]);
    }
  });
  
  return intel;
}

/* ========= URL Analysis ========= */
function analyzeURL(url){
  try {
    const parsed = new URL(url);
    const analysis = {
      protocol: parsed.protocol,
      hostname: parsed.hostname,
      port: parsed.port || (parsed.protocol === 'https:' ? '443' : '80'),
      path: parsed.pathname,
      query: parsed.search,
      fragment: parsed.hash,
      subdomains: [],
      parameters: {},
      suspiciousIndicators: []
    };
    
    // Extract subdomains
    const parts = parsed.hostname.split('.');
    if(parts.length > 2){
      analysis.subdomains = parts.slice(0, -2);
    }
    
    // Parse parameters
    if(parsed.search){
      const params = new URLSearchParams(parsed.search);
      for(const [key, value] of params){
        analysis.parameters[key] = value;
      }
    }
    
    // Detect suspicious indicators
    const suspicious = [
      { pattern: /bit\.ly|tinyurl|t\.co|goo\.gl/, indicator: 'URL_SHORTENER' },
      { pattern: /[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/, indicator: 'IP_ADDRESS_HOST' },
      { pattern: /[a-f0-9]{8,}/, indicator: 'HEX_SUBDOMAIN' },
      { pattern: /\.tk$|\.ml$|\.ga$|\.cf$/, indicator: 'SUSPICIOUS_TLD' },
      { pattern: /admin|login|secure|update|verify/, indicator: 'PHISHING_KEYWORDS' }
    ];
    
    suspicious.forEach(({pattern, indicator}) => {
      if(pattern.test(url)){
        analysis.suspiciousIndicators.push(indicator);
      }
    });
    
    return analysis;
  } catch(e) {
    return { error: 'Invalid URL format' };
  }
}

/* ========= Social Media Intelligence ========= */
function analyzeSocialMedia(text){
  const social = {
    platforms: [],
    mentions: [],
    hashtags: [],
    sentiment: 'neutral',
    languages: [],
    engagement: {}
  };
  
  // Platform detection
  const platforms = {
    twitter: /@[A-Za-z0-9_]+|twitter\.com|t\.co/g,
    instagram: /instagram\.com|@[a-zA-Z0-9._]+/g,
    facebook: /facebook\.com|fb\.com/g,
    linkedin: /linkedin\.com|in\//g,
    telegram: /t\.me\/|@[A-Za-z0-9_]+bot/g,
    discord: /discord\.gg\/|discord\.com/g,
    reddit: /reddit\.com\/r\/|\/u\//g,
    github: /github\.com/g
  };
  
  Object.entries(platforms).forEach(([platform, regex]) => {
    if(regex.test(text)){
      social.platforms.push(platform);
    }
  });
  
  // Extract hashtags
  const hashtagRegex = /#[A-Za-z0-9_]+/g;
  let match;
  while((match = hashtagRegex.exec(text)) !== null){
    social.hashtags.push(match[0]);
  }
  
  // Basic sentiment analysis
  const positiveWords = /\b(good|great|awesome|love|amazing|excellent|perfect|wonderful)\b/gi;
  const negativeWords = /\b(bad|terrible|awful|hate|horrible|disgusting|worst)\b/gi;
  
  const positiveCount = (text.match(positiveWords) || []).length;
  const negativeCount = (text.match(negativeWords) || []).length;
  
  if(positiveCount > negativeCount) social.sentiment = 'positive';
  else if(negativeCount > positiveCount) social.sentiment = 'negative';
  
  return social;
}

/* ========= Threat Assessment ========= */
function assessThreat(intel, fileInfo){
  let score = 0;
  const indicators = [];
  
  // File-based indicators
  if(fileInfo?.suspicious){
    score += 30;
    indicators.push('SUSPICIOUS_FILE_TYPE');
  }
  
  // Network indicators
  if(intel.ips?.length > 5){
    score += 20;
    indicators.push('MULTIPLE_IP_ADDRESSES');
  }
  
  if(intel.cryptoAddresses?.length > 0){
    score += 25;
    indicators.push('CRYPTOCURRENCY_ADDRESSES');
  }
  
  if(intel.suspiciousStrings?.length > 0){
    score += 40;
    indicators.push('SUSPICIOUS_COMMANDS');
  }
  
  if(intel.base64Strings?.length > 0){
    score += 15;
    indicators.push('BASE64_ENCODED_DATA');
  }
  
  if(intel.cves?.length > 0){
    score += 35;
    indicators.push('CVE_REFERENCES');
  }
  
  // Determine threat level
  let level = 'LOW';
  if(score >= 70) level = 'CRITICAL';
  else if(score >= 50) level = 'HIGH';
  else if(score >= 30) level = 'MEDIUM';
  
  return { level, score, indicators };
}

/* ========= Intelligence Search Queries ========= */
function buildIntelQueries(intel){
  const queries = [];
  
  // IOC-based queries
  (intel.ips || []).forEach(ip => {
    queries.push(`"${ip}" filetype:txt OR filetype:log`);
    queries.push(`site:virustotal.com "${ip}"`);
  });
  
  (intel.domains || []).forEach(domain => {
    queries.push(`site:${domain} OR "${domain}" -site:${domain}`);
    queries.push(`"${domain}" malware OR phishing OR threat`);
  });
  
  (intel.hashes || []).forEach(hash => {
    queries.push(`"${hash}" filetype:txt OR filetype:log`);
    queries.push(`site:virustotal.com "${hash}"`);
  });
  
  (intel.emails || []).forEach(email => {
    queries.push(`"${email}" -site:${email.split('@')[1]}`);
  });
  
  (intel.handles || []).forEach(handle => {
    queries.push(`"${handle}" site:twitter.com`);
    queries.push(`"${handle.replace('@', '')}" social media`);
  });
  
  return queries.slice(0, 12); // Top 12 most relevant
}

/* ========= Network Visualization ========= */
function updateNetworkGraph(intel){
  const networkLayer = el('#networkLayer');
  networkLayer.innerHTML = '';
  
  // Clear placeholder text
  const placeholder = el('#map text');
  if(placeholder) placeholder.style.display = 'none';
  
  const svgNS = 'http://www.w3.org/2000/svg';
  const entities = [];
  
  // Collect all entities with types
  (intel.domains || []).forEach(d => entities.push({value: d, type: 'domain', color: '#bf7b2d'}));
  (intel.ips || []).forEach(ip => entities.push({value: ip, type: 'ip', color: '#c21a1a'}));
  (intel.emails || []).forEach(e => entities.push({value: e, type: 'email', color: '#2d7bbf'}));
  (intel.handles || []).forEach(h => entities.push({value: h, type: 'handle', color: '#7b2dbf'}));
  (intel.phones || []).forEach(p => entities.push({value: p, type: 'phone', color: '#2dbf7b'}));
  
  if(entities.length === 0) {
    const text = document.createElementNS(svgNS, 'text');
    text.setAttribute('x', '50%');
    text.setAttribute('y', '50%');
    text.setAttribute('fill', '#6b6b6b');
    text.setAttribute('font-size', '12');
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('dy', '.35em');
    text.textContent = 'No entities to visualize';
    networkLayer.appendChild(text);
    return;
  }
  
  // Limit entities and create network layout
  const maxEntities = 12;
  const nodes = entities.slice(0, maxEntities);
  
  // Central hub for connected entities
  const centerX = 180, centerY = 90;
  
  // Draw connections first (behind nodes)
  if(nodes.length > 1) {
    nodes.forEach((node, i) => {
      // Connect domains to emails from same domain
      if(node.type === 'domain') {
        nodes.forEach((other, j) => {
          if(other.type === 'email' && other.value.includes(node.value)) {
            const angle1 = (i / nodes.length) * 2 * Math.PI;
            const angle2 = (j / nodes.length) * 2 * Math.PI;
            const x1 = centerX + Math.cos(angle1) * 70;
            const y1 = centerY + Math.sin(angle1) * 50;
            const x2 = centerX + Math.cos(angle2) * 70;
            const y2 = centerY + Math.sin(angle2) * 50;
            
            const line = document.createElementNS(svgNS, 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', '#444');
            line.setAttribute('stroke-width', '1');
            line.setAttribute('opacity', '0.6');
            networkLayer.appendChild(line);
          }
        });
      }
    });
  }
  
  // Draw nodes
  nodes.forEach((node, i) => {
    const angle = (i / nodes.length) * 2 * Math.PI;
    const radius = nodes.length > 6 ? 70 : 50;
    const x = centerX + Math.cos(angle) * radius;
    const y = centerY + Math.sin(angle) * (radius * 0.7); // Flatten vertically
    
    // Node circle
    const circle = document.createElementNS(svgNS, 'circle');
    circle.setAttribute('cx', x);
    circle.setAttribute('cy', y);
    circle.setAttribute('r', node.type === 'ip' ? '5' : '4');
    circle.setAttribute('fill', node.color);
    circle.setAttribute('stroke', '#fff');
    circle.setAttribute('stroke-width', '1');
    circle.setAttribute('opacity', '0.9');
    
    // Add subtle glow for IPs (potential threats)
    if(node.type === 'ip') {
      circle.setAttribute('filter', 'drop-shadow(0 0 3px #c21a1a)');
    }
    
    // Node label
    const text = document.createElementNS(svgNS, 'text');
    text.setAttribute('x', x);
    text.setAttribute('y', y - 10);
    text.setAttribute('fill', '#ddd');
    text.setAttribute('font-size', '8');
    text.setAttribute('text-anchor', 'middle');
    text.setAttribute('font-weight', '500');
    
    // Truncate long labels intelligently
    let label = node.value;
    if(node.type === 'email' && label.length > 20) {
      const parts = label.split('@');
      label = parts[0].substring(0, 8) + '...@' + parts[1];
    } else if(label.length > 15) {
      label = label.substring(0, 12) + '...';
    }
    text.textContent = label;
    
    // Type indicator
    const typeText = document.createElementNS(svgNS, 'text');
    typeText.setAttribute('x', x);
    typeText.setAttribute('y', y + 15);
    typeText.setAttribute('fill', node.color);
    typeText.setAttribute('font-size', '6');
    typeText.setAttribute('text-anchor', 'middle');
    typeText.setAttribute('opacity', '0.8');
    typeText.textContent = node.type.toUpperCase();
    
    networkLayer.appendChild(circle);
    networkLayer.appendChild(text);
    networkLayer.appendChild(typeText);
  });
  
  // Add entity count indicator
  if(entities.length > maxEntities) {
    const moreText = document.createElementNS(svgNS, 'text');
    moreText.setAttribute('x', '320');
    moreText.setAttribute('y', '170');
    moreText.setAttribute('fill', '#888');
    moreText.setAttribute('font-size', '10');
    moreText.setAttribute('text-anchor', 'end');
    moreText.textContent = `+${entities.length - maxEntities} more entities`;
    networkLayer.appendChild(moreText);
  }
  
  // Legend
  const legendY = 15;
  const legendItems = [
    {type: 'IP', color: '#c21a1a'},
    {type: 'Domain', color: '#bf7b2d'},
    {type: 'Email', color: '#2d7bbf'},
    {type: 'Handle', color: '#7b2dbf'},
    {type: 'Phone', color: '#2dbf7b'}
  ];
  
  legendItems.forEach((item, i) => {
    const x = 10 + i * 55;
    const circle = document.createElementNS(svgNS, 'circle');
    circle.setAttribute('cx', x);
    circle.setAttribute('cy', legendY);
    circle.setAttribute('r', '3');
    circle.setAttribute('fill', item.color);
    
    const text = document.createElementNS(svgNS, 'text');
    text.setAttribute('x', x + 8);
    text.setAttribute('y', legendY + 1);
    text.setAttribute('fill', '#999');
    text.setAttribute('font-size', '8');
    text.textContent = item.type;
    
    networkLayer.appendChild(circle);
    networkLayer.appendChild(text);
  });
}

/* ========= UI Event Handlers ========= */
const filedrop = el('#filedrop');
const textin = el('#textin');
const urlin = el('#urlin');
const metaNode = el('#meta');
const hashNode = el('#hash');
const threatLevelNode = el('#threatLevel');
let currentReport = {
  timestamp: Date.now(),
  sources: [],
  intelligence: {},
  threats: {},
  queries: [],
  files: {}
};

// File handling
filedrop.addEventListener('click', () => {
  const inp = document.createElement('input');
  inp.type = 'file';
  inp.multiple = true;
  // Accept all file types for comprehensive analysis
  inp.onchange = () => Array.from(inp.files).forEach(handleFile);
  inp.click();
});

filedrop.addEventListener('dragover', e => {
  e.preventDefault();
  filedrop.style.background = 'rgba(255,0,0,.03)';
});

filedrop.addEventListener('dragleave', e => {
  filedrop.style.background = '';
});

filedrop.addEventListener('drop', e => {
  e.preventDefault();
  filedrop.style.background = '';
  const files = Array.from(e.dataTransfer.files);
  files.forEach(handleFile);
});

async function handleFile(file){
  setStatus('analyzing file');
  
  try {
    const [hash, fileInfo] = await Promise.all([
      hashFile(file),
      analyzeFileHeader(file)
    ]);
    
    hashNode.textContent = hash;
    currentReport.files[file.name] = {
      hash,
      size: file.size,
      type: file.type,
      detected: fileInfo.type,
      suspicious: fileInfo.suspicious,
      timestamp: Date.now()
    };
    
    currentReport.sources.push({
      type: 'file',
      name: file.name,
      timestamp: Date.now()
    });
    
    const threat = assessThreat({}, fileInfo);
    updateThreatDisplay(threat);
    
    let output = `=== FILE ANALYSIS ===\n`;
    output += `Name: ${file.name}\n`;
    output += `Size: ${(file.size / 1024).toFixed(1)} KB\n`;
    output += `Type: ${fileInfo.type}${fileInfo.suspicious ? ' (SUSPICIOUS)' : ''}\n`;
    output += `SHA-256: ${hash}\n`;
    output += `Threat Level: ${threat.level}\n`;
    
    if(threat.indicators.length > 0){
      output += `\nThreat Indicators:\n`;
      threat.indicators.forEach(ind => output += `• ${ind}\n`);
    }
    
    metaNode.textContent = output;
    
  } catch(e) {
    hashNode.textContent = 'error';
    metaNode.textContent = `Error analyzing file: ${e.message}`;
  }
  
  setStatus('idle');
}

// URL Analysis
el('#analyzeUrl').addEventListener('click', () => {
  setStatus('analyzing URL');
  const url = urlin.value.trim();
  
  if(!url){
    setStatus('idle');
    return;
  }
  
  const analysis = analyzeURL(url);
  currentReport.sources.push({
    type: 'url',
    value: url,
    timestamp: Date.now()
  });
  
  let output = `=== URL ANALYSIS ===\n`;
  if(analysis.error){
    output += `Error: ${analysis.error}\n`;
  } else {
    output += `Protocol: ${analysis.protocol}\n`;
    output += `Host: ${analysis.hostname}\n`;
    output += `Port: ${analysis.port}\n`;
    output += `Path: ${analysis.path}\n`;
    
    if(analysis.subdomains.length > 0){
      output += `Subdomains: ${analysis.subdomains.join(', ')}\n`;
    }
    
    if(Object.keys(analysis.parameters).length > 0){
      output += `\nParameters:\n`;
      Object.entries(analysis.parameters).forEach(([key, val]) => {
        output += `• ${key}: ${val}\n`;
      });
    }
    
    if(analysis.suspiciousIndicators.length > 0){
      output += `\nSuspicious Indicators:\n`;
      analysis.suspiciousIndicators.forEach(ind => output += `• ${ind}\n`);
    }
    
    currentReport.intelligence.url = analysis;
    updateNetworkGraph({ domains: [analysis.hostname] });
  }
  
  metaNode.textContent = output;
  setStatus('idle');
});

// Text Intelligence Extraction
el('#analyzeText').addEventListener('click', () => {
  setStatus('extracting intelligence');
  const text = textin.value || '';
  const intel = extractIntelligence(text);
  
  currentReport.intelligence.extracted = intel;
  currentReport.sources.push({
    type: 'text',
    length: text.length,
    timestamp: Date.now()
  });
  
  const threat = assessThreat(intel);
  updateThreatDisplay(threat);
  currentReport.threats = threat;
  
  const queries = buildIntelQueries(intel);
  currentReport.queries = queries;
  
  let output = `=== INTELLIGENCE EXTRACTION ===\n`;
  output += `Emails: ${intel.emails.length ? intel.emails.slice(0,5).join(', ') + (intel.emails.length > 5 ? '...' : '') : '—'}\n`;
  output += `Domains: ${intel.domains.length ? intel.domains.slice(0,5).join(', ') + (intel.domains.length > 5 ? '...' : '') : '—'}\n`;
  output += `IPs: ${intel.ips.length ? intel.ips.slice(0,5).join(', ') + (intel.ips.length > 5 ? '...' : '') : '—'}\n`;
  output += `URLs: ${intel.urls.length ? intel.urls.length + ' found' : '—'}\n`;
  output += `Crypto Addresses: ${intel.cryptoAddresses.length ? intel.cryptoAddresses.join(', ') : '—'}\n`;
  output += `Hashes: ${intel.hashes.length ? intel.hashes.length + ' found' : '—'}\n`;
  output += `CVEs: ${intel.cves.length ? intel.cves.join(', ') : '—'}\n`;
  output += `Phone Numbers: ${intel.phones.length ? intel.phones.slice(0,3).join(', ') : '—'}\n`;
  output += `Handles: ${intel.handles.length ? intel.handles.slice(0,5).join(', ') : '—'}\n`;
  
  if(intel.suspiciousStrings.length > 0){
    output += `\nSuspicious Commands:\n`;
    intel.suspiciousStrings.forEach(str => output += `• ${str}\n`);
  }
  
  output += `\n=== THREAT ASSESSMENT ===\n`;
  output += `Level: ${threat.level} (Score: ${threat.score})\n`;
  if(threat.indicators.length > 0){
    output += `Indicators:\n`;
    threat.indicators.forEach(ind => output += `• ${ind}\n`);
  }
  
  output += `\n=== INTELLIGENCE QUERIES ===\n`;
  queries.slice(0,6).forEach(q => output += `• ${q}\n`);
  
  updateNetworkGraph(intel);
  metaNode.textContent = output;
  setStatus('idle');
});

// Social Media Analysis
el('#analyzeSocial').addEventListener('click', () => {
  setStatus('analyzing social media');
  const text = textin.value || '';
  const social = analyzeSocialMedia(text);
  
  currentReport.intelligence.social = social;
  
  let output = `=== SOCIAL MEDIA INTELLIGENCE ===\n`;
  output += `Platforms: ${social.platforms.length ? social.platforms.join(', ') : '—'}\n`;
  output += `Hashtags: ${social.hashtags.length ? social.hashtags.slice(0,8).join(', ') : '—'}\n`;
  output += `Sentiment: ${social.sentiment}\n`;
  
  if(social.platforms.length > 0){
    output += `\nPlatform-Specific Queries:\n`;
    social.platforms.forEach(platform => {
      output += `• site:${platform}.com "${text.substring(0,30)}..."\n`;
    });
  }
  
  metaNode.textContent = output;
  setStatus('idle');
});

function updateThreatDisplay(threat){
  threatLevelNode.textContent = `threat: ${threat.level}`;
  threatLevelNode.style.color = {
    'LOW': '#4ade80',
    'MEDIUM': '#fbbf24', 
    'HIGH': '#f97316',
    'CRITICAL': '#ef4444'
  }[threat.level] || '#9ca3af';
}

// Copy functions
el('#copyIntel').addEventListener('click', () => {
  const report = JSON.stringify(currentReport, null, 2);
  navigator.clipboard.writeText(report).then(
    () => setStatus('copied report'),
    () => setStatus('copy failed')
  );
});

el('#copyIOCs').addEventListener('click', () => {
  const intel = currentReport.intelligence.extracted || {};
  const iocs = [
    ...(intel.ips || []),
    ...(intel.domains || []), 
    ...(intel.hashes || []),
    ...(intel.urls || [])
  ];
  
  const iocText = iocs.join('\n');
  navigator.clipboard.writeText(iocText).then(
    () => setStatus('copied IOCs'),
    () => setStatus('copy failed')
  );
});

el('#copyHash').addEventListener('click', () => {
  const hash = hashNode.textContent || '';
  if(!hash || hash === '—') return alert('No hash to copy');
  navigator.clipboard.writeText(hash).then(
    () => setStatus('copied hash'),
    () => setStatus('copy failed')
  );
});

// Export functionality
el('#exportBtn').addEventListener('click', () => {
  const timestamp = new Date().toISOString().slice(0,19).replace(/[:.]/g, '-');
  const filename = `redfront-intel-${timestamp}.json`;
  
  const blob = new Blob([JSON.stringify(currentReport, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(() => URL.revokeObjectURL(url), 2000);
});

// Initialize
setStatus('idle');
metaNode.textContent = 'No input yet. Drop files, paste URLs, or analyze text to begin.';
</script>
</body>
</html>
